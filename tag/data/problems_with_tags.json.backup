{
  "problems": {
    "abc175_c": {
      "contest_id": "abc175",
      "problem_index": "C",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc175/tasks/abc175_c",
      "editorial_url": "https://atcoder.jp/contests/abc175/editorial/52",
      "editorial_id": 52,
      "tags": [
        "格子点",
        "DP",
        "GCD"
      ],
      "tag_ids": [
        "LAT",
        "DP",
        "GCD"
      ],
      "confidence_scores": [
        0.5522534835167333,
        0.3084207506013931,
        0.2511880228762863
      ],
      "avg_confidence": 0.3706207523314709,
      "min_confidence": 0.2511880228762863,
      "confidence_std": 0.13054177635040157,
      "low_confidence": true,
      "detailed_confidence": {
        "LAT": {
          "tag_name": "格子点",
          "composite_confidence": 0.5522534835167333,
          "components": {
            "self_confidence": 0.85,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7075116117224444
          },
          "reasoning": "本質的に1次元格子点上をD刻みで移動する問題であり、到達可能性を整数格子上の条件(合同式・偶奇)で扱っているため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.3084207506013931,
          "components": {
            "self_confidence": 0.15,
            "verifier_score": 0.1,
            "embedding_similarity": 0.7280691686713104
          },
          "reasoning": "K回の移動で到達可能なYを考える際に状態(i,残り回数)の可否を考える点でDP的要素がわずかにあるが、実際は閉形式で解かれておりDP実装は不要。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "GCD": {
          "tag_name": "GCD",
          "composite_confidence": 0.2511880228762863,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7039600762542875
          },
          "reasoning": "X≡Y (mod D)の条件はDとXの剰余を扱う点でGCD的には弱く関連するが、実際にGCD計算は用いられない。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1443,
      "inferred_at": "2025-08-16T15:19:22.016993",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc175_d": {
      "contest_id": "abc175",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc175/tasks/abc175_d",
      "editorial_url": "https://atcoder.jp/contests/abc175/editorial/53",
      "editorial_id": 53,
      "tags": [
        "累積和",
        "DP",
        "半分全列挙"
      ],
      "tag_ids": [
        "CUM",
        "DP",
        "MIT"
      ],
      "confidence_scores": [
        0.8927944735439504,
        0.3812047642820692,
        0.26194459220704697
      ],
      "avg_confidence": 0.5119812766776889,
      "min_confidence": 0.26194459220704697,
      "confidence_std": 0.27364181617760536,
      "low_confidence": true,
      "detailed_confidence": {
        "CUM": {
          "tag_name": "累積和",
          "composite_confidence": 0.8927944735439504,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7093149118131681
          },
          "reasoning": "The solution relies on computing prefix sums around each cycle to quickly evaluate partial sums over any segment of the cycle (i.e. cumulative sums).",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.3812047642820692,
          "components": {
            "self_confidence": 0.4,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7373492142735638
          },
          "reasoning": "Although the main idea is greedy (take as many full cycles as possible, then best remainder), finding the best partial path over up to L steps on a cycle can be viewed as a small DP/optimization over segment sums.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MIT": {
          "tag_name": "半分全列挙",
          "composite_confidence": 0.26194459220704697,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7398153073568232
          },
          "reasoning": "The algorithm does brute‐force over all possible ‘remainders’ on a cycle (up to its length), reminiscent of half‐enumeration in that it tries all offsets—though it isn’t a true meet‐in‐the‐middle.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 745,
      "inferred_at": "2025-08-16T15:19:25.813119",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc175_e": {
      "contest_id": "abc175",
      "problem_index": "E",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc175/tasks/abc175_e",
      "editorial_url": "https://atcoder.jp/contests/abc175/editorial/54",
      "editorial_id": 54,
      "tags": [
        "DP",
        "全探索",
        "累積和"
      ],
      "tag_ids": [
        "DP",
        "BRT",
        "CUM"
      ],
      "confidence_scores": [
        0.9309275425201016,
        0.3031435305251639,
        0.2635468598316355
      ],
      "avg_confidence": 0.4992059776256337,
      "min_confidence": 0.2635468598316355,
      "confidence_std": 0.3057009500352691,
      "low_confidence": true,
      "detailed_confidence": {
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.9309275425201016,
          "components": {
            "self_confidence": 1.0,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7697584750670055
          },
          "reasoning": "The core solution uses dynamic programming with state f[i][j][k], tracking position and number of items picked in the current row, with O(R×C) transitions.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BRT": {
          "tag_name": "全探索",
          "composite_confidence": 0.3031435305251639,
          "components": {
            "self_confidence": 0.2,
            "verifier_score": 0.0,
            "embedding_similarity": 0.743811768417213
          },
          "reasoning": "A naive brute‐force approach would try all combinations of up to three pick‐positions per row (O(C³) per row), which the editorial mentions and rejects as too slow.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CUM": {
          "tag_name": "累積和",
          "composite_confidence": 0.2635468598316355,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.745156199438785
          },
          "reasoning": "One might consider using row‐wise prefix sums to speed up range or repeated sum queries of item values, although the official DP does not require it explicitly.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 767,
      "inferred_at": "2025-08-16T15:19:34.345059",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc175_f": {
      "contest_id": "abc175",
      "problem_index": "F",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc175/tasks/abc175_f",
      "editorial_url": "https://atcoder.jp/contests/abc175/editorial/55",
      "editorial_id": 55,
      "tags": [
        "ダイクストラ",
        "回文判定",
        "LCP"
      ],
      "tag_ids": [
        "DJK",
        "PAL",
        "LCP"
      ],
      "confidence_scores": [
        0.8947204572965108,
        0.593875443911626,
        0.34698821778611244
      ],
      "avg_confidence": 0.6118613729980832,
      "min_confidence": 0.34698821778611244,
      "confidence_std": 0.2239721288964268,
      "low_confidence": true,
      "detailed_confidence": {
        "DJK": {
          "tag_name": "ダイクストラ",
          "composite_confidence": 0.8947204572965108,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7157348576550363
          },
          "reasoning": "The solution models the problem as a shortest‐path problem on a graph of string remainders and explicitly recommends using Dijkstra’s algorithm to find the minimal cost to reach a palindrome state.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "PAL": {
          "tag_name": "回文判定",
          "composite_confidence": 0.593875443911626,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7795848130387535
          },
          "reasoning": "The core of the problem is constructing a palindrome by appending given strings to the left or right and checking palindromicity of the growing string, so palindrome handling is fundamental.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "LCP": {
          "tag_name": "LCP",
          "composite_confidence": 0.34698821778611244,
          "components": {
            "self_confidence": 0.3,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7566273926203748
          },
          "reasoning": "Transitions depend on matching prefixes and suffixes of candidate strings against the unmatched portion—this is essentially an LCP/suffix matching concern, though the editorial suggests brute comparisons rather than a dedicated LCP algorithm.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 961,
      "inferred_at": "2025-08-16T15:19:52.251929",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc176_d": {
      "contest_id": "abc176",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc176/tasks/abc176_d",
      "editorial_url": "https://atcoder.jp/contests/abc176/editorial/65",
      "editorial_id": 65,
      "tags": [
        "0-1 BFS",
        "BFS",
        "ダイクストラ"
      ],
      "tag_ids": [
        "01B",
        "BFS",
        "DJK"
      ],
      "confidence_scores": [
        0.9297095087338316,
        0.8815141470923707,
        0.7172711717384367
      ],
      "avg_confidence": 0.8428316091882131,
      "min_confidence": 0.7172711717384367,
      "confidence_std": 0.09093868194328233,
      "low_confidence": false,
      "detailed_confidence": {
        "01B": {
          "tag_name": "0-1 BFS",
          "composite_confidence": 0.9297095087338316,
          "components": {
            "self_confidence": 1.0,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7656983624461055
          },
          "reasoning": "The editorial explicitly describes the 0-1 BFS algorithm (“01-BFS”), using a deque to push cost-0 moves to the front and cost-1 moves to the back.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BFS": {
          "tag_name": "BFS",
          "composite_confidence": 0.8815141470923707,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7383804903079025
          },
          "reasoning": "The solution repeatedly uses breadth-first search to enumerate all cells reachable with the current cost-0 moves before increasing the cost, as described in the editorial.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DJK": {
          "tag_name": "ダイクストラ",
          "composite_confidence": 0.7172711717384367,
          "components": {
            "self_confidence": 0.5,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7242372391281224
          },
          "reasoning": "This is a shortest‐path problem on a grid with non-negative weights (0 or 1), which can also be solved by Dijkstra’s algorithm, though the editorial focuses on the specialized 0-1 BFS.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1073,
      "inferred_at": "2025-08-16T15:19:50.636307",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc176_e": {
      "contest_id": "abc176",
      "problem_index": "E",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc176/tasks/abc176_e",
      "editorial_url": "https://atcoder.jp/contests/abc176/editorial/66",
      "editorial_id": 66,
      "tags": [
        "全探索",
        "最適化",
        "組み合わせ"
      ],
      "tag_ids": [
        "BRT",
        "OPT",
        "CMB"
      ],
      "confidence_scores": [
        0.8789947930457722,
        0.6313422891717945,
        0.2951586351940838
      ],
      "avg_confidence": 0.6018319058038836,
      "min_confidence": 0.2951586351940838,
      "confidence_std": 0.23926179782635063,
      "low_confidence": true,
      "detailed_confidence": {
        "BRT": {
          "tag_name": "全探索",
          "composite_confidence": 0.8789947930457722,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7299826434859071
          },
          "reasoning": "The solution involves computing counts for each row and column and then brute-forcing over candidate row–column pairs (at most M checks), fitting the full search category.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "OPT": {
          "tag_name": "最適化",
          "composite_confidence": 0.6313422891717945,
          "components": {
            "self_confidence": 0.3,
            "verifier_score": 1.0,
            "embedding_similarity": 0.704474297239315
          },
          "reasoning": "We greedily choose the row and column with the maximum bomb counts to maximize the total destruction, an optimization step to find the best A and B.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CMB": {
          "tag_name": "組み合わせ",
          "composite_confidence": 0.2951586351940838,
          "components": {
            "self_confidence": 0.2,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7171954506469461
          },
          "reasoning": "After selecting the maxima, we consider combinations of those rows and columns (pairs) and test each for the presence of a bomb to adjust the answer accordingly.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1906,
      "inferred_at": "2025-08-16T15:20:03.967735",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc176_f": {
      "contest_id": "abc176",
      "problem_index": "F",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc176/tasks/abc176_f",
      "editorial_url": "https://atcoder.jp/contests/abc176/editorial/67",
      "editorial_id": 67,
      "tags": [
        "DP",
        "最適化",
        "bitDP"
      ],
      "tag_ids": [
        "DP",
        "OPT",
        "BDP"
      ],
      "confidence_scores": [
        0.9275869421243239,
        0.6781939998880414,
        0.2459744943662997
      ],
      "avg_confidence": 0.6172518121262217,
      "min_confidence": 0.2459744943662997,
      "confidence_std": 0.2815840252589731,
      "low_confidence": true,
      "detailed_confidence": {
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.9275869421243239,
          "components": {
            "self_confidence": 0.98,
            "verifier_score": 1.0,
            "embedding_similarity": 0.78528980708108
          },
          "reasoning": "The solution is based on a straightforward dynamic programming formulation DP[i][x][y] with O(N) transitions.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "OPT": {
          "tag_name": "最適化",
          "composite_confidence": 0.6781939998880414,
          "components": {
            "self_confidence": 0.4,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7273133329601381
          },
          "reasoning": "The goal is to maximize the total score, so it is essentially an optimization problem built on top of the DP state.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BDP": {
          "tag_name": "bitDP",
          "composite_confidence": 0.2459744943662997,
          "components": {
            "self_confidence": 0.05,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7532483145543323
          },
          "reasoning": "There is no bitmask DP here, but this tag is included with low confidence as a placeholder to complete the requirement of three tags.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1727,
      "inferred_at": "2025-08-16T15:20:13.714585",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc177_c": {
      "contest_id": "abc177",
      "problem_index": "C",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc177/tasks/abc177_c",
      "editorial_url": "https://atcoder.jp/contests/abc177/editorial/88",
      "editorial_id": 88,
      "tags": [
        "累積和",
        "Imos法",
        "平方分割"
      ],
      "tag_ids": [
        "CUM",
        "IMO",
        "SQD"
      ],
      "confidence_scores": [
        0.8895138842758499,
        0.26872864809873054,
        0.24554539920425295
      ],
      "avg_confidence": 0.4679293105262778,
      "min_confidence": 0.24554539920425295,
      "confidence_std": 0.29825551727227906,
      "low_confidence": true,
      "detailed_confidence": {
        "CUM": {
          "tag_name": "累積和",
          "composite_confidence": 0.8895138842758499,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7650462809194993
          },
          "reasoning": "The editorial explicitly uses 累積和 (prefix sums) to compute the sum of A[j] for j>i in O(1) time.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "IMO": {
          "tag_name": "Imos法",
          "composite_confidence": 0.26872864809873054,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7624288269957684
          },
          "reasoning": "Imos法 is another prefix‐sum technique for range updates, but here only simple cumulative sums are used; it’s unlikely but a related mis‐association.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "SQD": {
          "tag_name": "平方分割",
          "composite_confidence": 0.24554539920425295,
          "components": {
            "self_confidence": 0.05,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7518179973475099
          },
          "reasoning": "平方分割 (sqrt‐decomposition) isn’t used in the solution; picked with very low confidence as a distractor.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 2113,
      "inferred_at": "2025-08-16T15:20:16.719174",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc177_d": {
      "contest_id": "abc177",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc177/tasks/abc177_d",
      "editorial_url": "https://atcoder.jp/contests/abc177/editorial/90",
      "editorial_id": 90,
      "tags": [
        "Union Find",
        "全探索",
        "区間スケジューリング"
      ],
      "tag_ids": [
        "UF",
        "BRT",
        "SCH"
      ],
      "confidence_scores": [
        0.918764512273063,
        0.23219884139159497,
        0.22331673616798223
      ],
      "avg_confidence": 0.45809336327754674,
      "min_confidence": 0.22331673616798223,
      "confidence_std": 0.3257638752081408,
      "low_confidence": true,
      "detailed_confidence": {
        "UF": {
          "tag_name": "Union Find",
          "composite_confidence": 0.918764512273063,
          "components": {
            "self_confidence": 0.98,
            "verifier_score": 1.0,
            "embedding_similarity": 0.755881707576877
          },
          "reasoning": "The solution builds and queries disjoint sets of friends, taking the maximum component size; classic Union-Find usage.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BRT": {
          "tag_name": "全探索",
          "composite_confidence": 0.23219884139159497,
          "components": {
            "self_confidence": 0.05,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7073294713053166
          },
          "reasoning": "One could view the round‐robin group assignment for each friend component as a brute‐force or straightforward assignment, though not truly exhaustive search.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "SCH": {
          "tag_name": "区間スケジューリング",
          "composite_confidence": 0.22331673616798223,
          "components": {
            "self_confidence": 0.03,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7043891205599407
          },
          "reasoning": "Superficially, partitioning people into groups to avoid conflicts resembles a scheduling or assignment problem, but it’s a weak fit.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 2018,
      "inferred_at": "2025-08-16T15:20:35.292670",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc177_e": {
      "contest_id": "abc177",
      "problem_index": "E",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc177/tasks/abc177_e",
      "editorial_url": "https://atcoder.jp/contests/abc177/editorial/82",
      "editorial_id": 82,
      "tags": [
        "素因数分解",
        "GCD",
        "素数"
      ],
      "tag_ids": [
        "PFT",
        "GCD",
        "PRM"
      ],
      "confidence_scores": [
        0.9138202049348487,
        0.8575031256943753,
        0.8055859823211806
      ],
      "avg_confidence": 0.8589697709834683,
      "min_confidence": 0.8055859823211806,
      "confidence_std": 0.04419860497420915,
      "low_confidence": false,
      "detailed_confidence": {
        "PFT": {
          "tag_name": "素因数分解",
          "composite_confidence": 0.9138202049348487,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7794006831161626
          },
          "reasoning": "問題の肝は複数の A_i をエラトステネスの篩＋spf（smallest prime factor）により高速に素因数分解する点にあり、PFT（素因数分解）が最も適切です。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "GCD": {
          "tag_name": "GCD",
          "composite_confidence": 0.8575031256943753,
          "components": {
            "self_confidence": 0.85,
            "verifier_score": 1.0,
            "embedding_similarity": 0.725010418981251
          },
          "reasoning": "pairwise coprime と setwise coprime の判定において GCD の計算が必須であり、GCDを用いた論法が解説全体を貫いています。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "PRM": {
          "tag_name": "素数",
          "composite_confidence": 0.8055859823211806,
          "components": {
            "self_confidence": 0.7,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7519532744039356
          },
          "reasoning": "エラトステネスの篩で素数を列挙・利用し、その結果をもとに各 A_i を素因数分解しているため、素数（PRM）も重要な要素です。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1287,
      "inferred_at": "2025-08-16T15:20:34.284795",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc177_f": {
      "contest_id": "abc177",
      "problem_index": "F",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc177/tasks/abc177_f",
      "editorial_url": "https://atcoder.jp/contests/abc177/editorial/83",
      "editorial_id": 83,
      "tags": [
        "貪欲法",
        "DP",
        "区間スケジューリング"
      ],
      "tag_ids": [
        "GRD",
        "DP",
        "SCH"
      ],
      "confidence_scores": [
        0.8776263485470339,
        0.3786454718864647,
        0.3490711225381091
      ],
      "avg_confidence": 0.5351143143238692,
      "min_confidence": 0.3490711225381091,
      "confidence_std": 0.2424933411121666,
      "low_confidence": true,
      "detailed_confidence": {
        "GRD": {
          "tag_name": "貪欲法",
          "composite_confidence": 0.8776263485470339,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7254211618234463
          },
          "reasoning": "The core path‐finding strategy is greedy: at each step move down if possible, otherwise move right, which is proved optimal for minimizing right moves.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.3786454718864647,
          "components": {
            "self_confidence": 0.4,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7288182396215489
          },
          "reasoning": "The algorithm maintains a state for each starting column and processes rows k in increasing order, updating minimal right‐move counts via range updates—this can be viewed as a form of DP over k.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "SCH": {
          "tag_name": "区間スケジューリング",
          "composite_confidence": 0.3490711225381091,
          "components": {
            "self_confidence": 0.3,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7635704084603637
          },
          "reasoning": "The procedure of managing (end, start) pairs and discarding dominated ones when intervals [A_k,B_k] overlap resembles interval scheduling techniques for pruning suboptimal intervals.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 947,
      "inferred_at": "2025-08-16T15:22:05.967899",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc178_c": {
      "contest_id": "abc178",
      "problem_index": "C",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc178/tasks/abc178_c",
      "editorial_url": "https://atcoder.jp/contests/abc178/editorial/104",
      "editorial_id": 104,
      "tags": [
        "組み合わせ",
        "整数",
        "ビット演算"
      ],
      "tag_ids": [
        "CMB",
        "INT",
        "BOP"
      ],
      "confidence_scores": [
        0.8980467288687292,
        0.5370187471895024,
        0.2980552591182789
      ],
      "avg_confidence": 0.5777069117255035,
      "min_confidence": 0.2980552591182789,
      "confidence_std": 0.24662939267020045,
      "low_confidence": true,
      "detailed_confidence": {
        "CMB": {
          "tag_name": "組み合わせ",
          "composite_confidence": 0.8980467288687292,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7268224295624308
          },
          "reasoning": "本問題は集合の要素（0,9の出現あり/なし）をカウントする際に包除原理を用いており、組み合わせ論的手法が中心であるため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "INT": {
          "tag_name": "整数",
          "composite_confidence": 0.5370187471895024,
          "components": {
            "self_confidence": 0.8,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7233958239650077
          },
          "reasoning": "10^N,9^N,8^N の計算を含む整数演算（べき乗・剰余）が主要処理であるため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BOP": {
          "tag_name": "ビット演算",
          "composite_confidence": 0.2980552591182789,
          "components": {
            "self_confidence": 0.2,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7268508637275963
          },
          "reasoning": "一般に高速べき乗（powmod）ではビット演算を用いる実装が多いが、サンプルでは単純ループも可。そのためやや弱い関連度。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1148,
      "inferred_at": "2025-08-16T15:22:04.757788",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc178_d": {
      "contest_id": "abc178",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc178/tasks/abc178_d",
      "editorial_url": "https://atcoder.jp/contests/abc178/editorial/101",
      "editorial_id": 101,
      "tags": [
        "DP",
        "組み合わせ",
        "累積和"
      ],
      "tag_ids": [
        "DP",
        "CMB",
        "CUM"
      ],
      "confidence_scores": [
        0.8811656994253965,
        0.558586142620993,
        0.5386980691071374
      ],
      "avg_confidence": 0.6594833037178423,
      "min_confidence": 0.5386980691071374,
      "confidence_std": 0.15696325959069446,
      "low_confidence": false,
      "detailed_confidence": {
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.8811656994253965,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7372189980846549
          },
          "reasoning": "問題は A[n] を A[n−3]+…+A[0] や A[n−1]+A[n−3] の漸化式で計算する典型的な動的計画法であるため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CMB": {
          "tag_name": "組み合わせ",
          "composite_confidence": 0.558586142620993,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7286204754033103
          },
          "reasoning": "要素の組み合わせ（合計が S となる数列）を数える問題という意味で組み合わせ的要素があるため。ただし、直接組み合わせ数式を用いてはいない。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CUM": {
          "tag_name": "累積和",
          "composite_confidence": 0.5386980691071374,
          "components": {
            "self_confidence": 0.8,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7289935636904575
          },
          "reasoning": "A[n]=A[n−3]+A[n−4]+…+A[0] から累積和 (prefix sum) を用いることで O(S) に高速化しているため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 727,
      "inferred_at": "2025-08-16T15:22:02.875938",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc178_f": {
      "contest_id": "abc178",
      "problem_index": "F",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc178/tasks/abc178_f",
      "editorial_url": "https://atcoder.jp/contests/abc178/editorial/84",
      "editorial_id": 84,
      "tags": [
        "区間スケジューリング",
        "中国剰余定理",
        "組み合わせ"
      ],
      "tag_ids": [
        "SCH",
        "CRT",
        "CMB"
      ],
      "confidence_scores": [
        0.5827019175343333,
        0.3030911137764121,
        0.2685637757463747
      ],
      "avg_confidence": 0.3847856023523734,
      "min_confidence": 0.2685637757463747,
      "confidence_std": 0.1406560465088835,
      "low_confidence": true,
      "detailed_confidence": {
        "SCH": {
          "tag_name": "区間スケジューリング",
          "composite_confidence": 0.5827019175343333,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7423397251144443
          },
          "reasoning": "問題文ではBをxだけ右にずらして三つの区間が重ならないようにする必要があり，いわゆる円上での区間の配置（区間スケジューリング）的な見方で解いているため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CRT": {
          "tag_name": "中国剰余定理",
          "composite_confidence": 0.3030911137764121,
          "components": {
            "self_confidence": 0.2,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7436370459213737
          },
          "reasoning": "xを0≤x≤Nの範囲で決める際に，Nを法とした循環シフトの考え方が登場する点が，中国剰余定理のイメージに近いと判断したため（ただし本質的には不等式の交差検索）。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CMB": {
          "tag_name": "組み合わせ",
          "composite_confidence": 0.2685637757463747,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7618792524879157
          },
          "reasoning": "冒頭で鳩の巣原理を用いて解が存在しない場合を除去している点は，組み合わせ的な考え方に通じると判断したため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1532,
      "inferred_at": "2025-08-16T15:22:30.067361",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc179_c": {
      "contest_id": "abc179",
      "problem_index": "C",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc179/tasks/abc179_c",
      "editorial_url": "https://atcoder.jp/contests/abc179/editorial/99",
      "editorial_id": 99,
      "tags": [
        "約数列挙",
        "組み合わせ",
        "平方分割"
      ],
      "tag_ids": [
        "DIV",
        "CMB",
        "SQD"
      ],
      "confidence_scores": [
        0.45935592379972245,
        0.4178283065471762,
        0.33368316597039804
      ],
      "avg_confidence": 0.4036224654390989,
      "min_confidence": 0.33368316597039804,
      "confidence_std": 0.05227979186580578,
      "low_confidence": true,
      "detailed_confidence": {
        "DIV": {
          "tag_name": "約数列挙",
          "composite_confidence": 0.45935592379972245,
          "components": {
            "self_confidence": 0.6,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7311864126657415
          },
          "reasoning": "The core step fixes A and uses floor division ⌊(N−1)/A⌋ to count valid B’s, so division-based counting is central.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CMB": {
          "tag_name": "組み合わせ",
          "composite_confidence": 0.4178283065471762,
          "components": {
            "self_confidence": 0.5,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7260943551572538
          },
          "reasoning": "We are effectively counting all ordered pairs (A,B) satisfying A×B<N, a basic combinatorial enumeration of pairs.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "SQD": {
          "tag_name": "平方分割",
          "composite_confidence": 0.33368316597039804,
          "components": {
            "self_confidence": 0.3,
            "verifier_score": 0.0,
            "embedding_similarity": 0.712277219901327
          },
          "reasoning": "Though the editorial uses an O(N) loop, the problem can be optimized by grouping intervals where ⌊(N−1)/A⌋ is constant—a square‐root decomposition trick often used in floor‐sum problems.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 573,
      "inferred_at": "2025-08-16T15:22:28.397725",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc179_d": {
      "contest_id": "abc179",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc179/tasks/abc179_d",
      "editorial_url": "https://atcoder.jp/contests/abc179/editorial/121",
      "editorial_id": 121,
      "tags": [
        "DP",
        "Imos法",
        "Alien DP"
      ],
      "tag_ids": [
        "DP",
        "IMO",
        "ADP"
      ],
      "confidence_scores": [
        0.9242611171428018,
        0.8961866605354101,
        0.5576163946279961
      ],
      "avg_confidence": 0.7926880574354026,
      "min_confidence": 0.5576163946279961,
      "confidence_std": 0.16661544300120038,
      "low_confidence": false,
      "detailed_confidence": {
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.9242611171428018,
          "components": {
            "self_confidence": 0.98,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7742037238093396
          },
          "reasoning": "問題の中心は状態f_iを定義して遷移を行う動的計画法（配るDP）であり、明らかにDPに該当する。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "IMO": {
          "tag_name": "Imos法",
          "composite_confidence": 0.8961866605354101,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7206222017847006
          },
          "reasoning": "区間加算を差分配列（a_i=f_i−f_{i−1}）と累積和で実装して高速化しており、まさにImos法（IMO）である。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "ADP": {
          "tag_name": "Alien DP",
          "composite_confidence": 0.5576163946279961,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7253879820933202
          },
          "reasoning": "範囲遷移を高速化する手法として他の応用DPに近い側面はあるが、本来の“Alien DP”とは異なるため、適用は弱いと判断した。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 956,
      "inferred_at": "2025-08-16T15:22:26.649214",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc179_e": {
      "contest_id": "abc179",
      "problem_index": "E",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc179/tasks/abc179_e",
      "editorial_url": "https://atcoder.jp/contests/abc179/editorial/115",
      "editorial_id": 115,
      "tags": [
        "累積和",
        "写像12相",
        "Imos法"
      ],
      "tag_ids": [
        "CUM",
        "MAP",
        "IMO"
      ],
      "confidence_scores": [
        0.6206914111324764,
        0.5747029640951179,
        0.2537184243334135
      ],
      "avg_confidence": 0.4830375998536693,
      "min_confidence": 0.2537184243334135,
      "confidence_std": 0.16323642875942118,
      "low_confidence": true,
      "detailed_confidence": {
        "CUM": {
          "tag_name": "累積和",
          "composite_confidence": 0.6206914111324764,
          "components": {
            "self_confidence": 0.85,
            "verifier_score": 0.2,
            "embedding_similarity": 0.7356380371082546
          },
          "reasoning": "前周期部・周期部・最後の部分の和を累積和的に計算し，O(M) で総和を求める手法を用いているため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MAP": {
          "tag_name": "写像12相",
          "composite_confidence": 0.5747029640951179,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7156765469837262
          },
          "reasoning": "問題は A_i の値を M 個のノード上の写像として扱い，サイクル検出と前周期部・周期部の長さを用いているため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "IMO": {
          "tag_name": "Imos法",
          "composite_confidence": 0.2537184243334135,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7123947477780451
          },
          "reasoning": "3つの区間（前周期部・周期部・残り）に分けて累積的に足し合わせる点で，いわゆる区間加算の拡張と捉えられなくもないが，直接的な Imos 法ではないため低めの確信度。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 731,
      "inferred_at": "2025-08-16T15:22:49.869387",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc179_f": {
      "contest_id": "abc179",
      "problem_index": "F",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc179/tasks/abc179_f",
      "editorial_url": "https://atcoder.jp/contests/abc179/editorial/122",
      "editorial_id": 122,
      "tags": [
        "Mo's algorithm",
        "全探索",
        "DP"
      ],
      "tag_ids": [
        "MOS",
        "BRT",
        "DP"
      ],
      "confidence_scores": [
        0.5515591774152566,
        0.27187209616053454,
        0.2512005222850573
      ],
      "avg_confidence": 0.3582105986202828,
      "min_confidence": 0.2512005222850573,
      "confidence_std": 0.13697830286374912,
      "low_confidence": true,
      "detailed_confidence": {
        "MOS": {
          "tag_name": "Mo's algorithm",
          "composite_confidence": 0.5515591774152566,
          "components": {
            "self_confidence": 0.85,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7051972580508552
          },
          "reasoning": "盤面の範囲（枠）をクエリに応じてO(1)で伸縮させながら管理する手法は、Mo’sアルゴリズムで区間の左右端を動かして値を更新する操作に酷似しているため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BRT": {
          "tag_name": "全探索",
          "composite_confidence": 0.27187209616053454,
          "components": {
            "self_confidence": 0.15,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7062403205351151
          },
          "reasoning": "ナイーブには各クエリで上下左右に石を走査して裏返し操作を行う全探索的実装（O(N)／クエリ）が考えられるが、本解法はこれを高速化しているため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.2512005222850573,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7040017409501911
          },
          "reasoning": "各列・各行の最前の石の位置を保持・更新しながら累積的にクエリの影響を蓄積する点で、漸進的に状態を更新するDP的要素があるとみなせるが、主たる手法は枠の伸縮にあるため確信度は低い。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1025,
      "inferred_at": "2025-08-16T15:22:56.980888",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc180_d": {
      "contest_id": "abc180",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc180/tasks/abc180_d",
      "editorial_url": "https://atcoder.jp/contests/abc180/editorial/219",
      "editorial_id": 219,
      "tags": [
        "全探索",
        "DP",
        "半分全列挙"
      ],
      "tag_ids": [
        "BRT",
        "DP",
        "MIT"
      ],
      "confidence_scores": [
        0.5708853308660167,
        0.25529653879538483,
        0.25468903967965045
      ],
      "avg_confidence": 0.360290303113684,
      "min_confidence": 0.25468903967965045,
      "confidence_std": 0.14891337873474908,
      "low_confidence": true,
      "detailed_confidence": {
        "BRT": {
          "tag_name": "全探索",
          "composite_confidence": 0.5708853308660167,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7029511028867219
          },
          "reasoning": "The solution essentially brute‐forces over the number of times to apply the multiplicative training (up to O(log_A Y)≈64) and then computes the rest in O(1), so it’s a controlled brute‐force enumeration.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.25529653879538483,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7176551293179494
          },
          "reasoning": "One might view it as a state transition (build strength up to Y), but there’s no DP table or overlapping subproblems—greedy suffices, so DP is unlikely.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MIT": {
          "tag_name": "半分全列挙",
          "composite_confidence": 0.25468903967965045,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7156301322655015
          },
          "reasoning": "There is an enumeration over possible counts of multiplicative steps, reminiscent of splitting into two parts, but there is no true meet-in-the-middle combination, so this is a weak fit.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1052,
      "inferred_at": "2025-08-16T15:22:53.296374",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc180_e": {
      "contest_id": "abc180",
      "problem_index": "E",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc180/tasks/abc180_e",
      "editorial_url": "https://atcoder.jp/contests/abc180/editorial/154",
      "editorial_id": 154,
      "tags": [
        "bitDP",
        "DP",
        "最適化"
      ],
      "tag_ids": [
        "BDP",
        "DP",
        "OPT"
      ],
      "confidence_scores": [
        0.9132289648922507,
        0.9020572027877539,
        0.7526705465206479
      ],
      "avg_confidence": 0.8559855714002175,
      "min_confidence": 0.7526705465206479,
      "confidence_std": 0.07319698464431182,
      "low_confidence": false,
      "detailed_confidence": {
        "BDP": {
          "tag_name": "bitDP",
          "composite_confidence": 0.9132289648922507,
          "components": {
            "self_confidence": 0.99,
            "verifier_score": 1.0,
            "embedding_similarity": 0.724096549640836
          },
          "reasoning": "The DP state uses bitmasking to represent subsets of visited cities (bit DP), and the editorial explicitly refers to this as bitDP.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.9020572027877539,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.74019067595918
          },
          "reasoning": "The solution uses a dynamic programming formulation DP[i][S] to compute the minimum cost, which is the textbook DP approach for the TSP.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "OPT": {
          "tag_name": "最適化",
          "composite_confidence": 0.7526705465206479,
          "components": {
            "self_confidence": 0.6,
            "verifier_score": 1.0,
            "embedding_similarity": 0.708901821735493
          },
          "reasoning": "The problem seeks the minimum travel cost (an optimization objective), so it falls under optimization problems.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1000,
      "inferred_at": "2025-08-16T15:23:05.246761",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc180_f": {
      "contest_id": "abc180",
      "problem_index": "F",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc180/tasks/abc180_f",
      "editorial_url": "https://atcoder.jp/contests/abc180/editorial/92",
      "editorial_id": 92,
      "tags": [
        "DP",
        "桁DP",
        "半分全列挙"
      ],
      "tag_ids": [
        "DP",
        "KDP",
        "MIT"
      ],
      "confidence_scores": [
        0.9039201845159653,
        0.24810265974632562,
        0.24007070904168443
      ],
      "avg_confidence": 0.46403118443465846,
      "min_confidence": 0.24007070904168443,
      "confidence_std": 0.3110657779874748,
      "low_confidence": true,
      "detailed_confidence": {
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.9039201845159653,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7464006150532181
          },
          "reasoning": "The solution is built around a two-dimensional dynamic programming on the number of vertices and edges assigned so far.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "KDP": {
          "tag_name": "桁DP",
          "composite_confidence": 0.24810265974632562,
          "components": {
            "self_confidence": 0.05,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7603421991544188
          },
          "reasoning": "This is a DP problem but does not involve digit-by-digit transitions; included with low confidence to satisfy the three-tag requirement.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MIT": {
          "tag_name": "半分全列挙",
          "composite_confidence": 0.24007070904168443,
          "components": {
            "self_confidence": 0.05,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7335690301389481
          },
          "reasoning": "The problem does not use a meet-in-the-middle strategy; included with minimal confidence to complete the tag list.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1396,
      "inferred_at": "2025-08-16T15:23:11.087491",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc181_c": {
      "contest_id": "abc181",
      "problem_index": "C",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc181/tasks/abc181_c",
      "editorial_url": "https://atcoder.jp/contests/abc181/editorial/258",
      "editorial_id": 258,
      "tags": [
        "幾何",
        "格子点",
        "座標回転"
      ],
      "tag_ids": [
        "GEO",
        "LAT",
        "ROT"
      ],
      "confidence_scores": [
        0.8903931847971803,
        0.6411120892071076,
        0.22761215763780746
      ],
      "avg_confidence": 0.5863724772140319,
      "min_confidence": 0.22761215763780746,
      "confidence_std": 0.2733337292657369,
      "low_confidence": true,
      "detailed_confidence": {
        "GEO": {
          "tag_name": "幾何",
          "composite_confidence": 0.8903931847971803,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7013106159906013
          },
          "reasoning": "This problem asks to determine whether any three points are collinear in the plane, which is a classic geometry task involving slopes or cross products.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "LAT": {
          "tag_name": "格子点",
          "composite_confidence": 0.6411120892071076,
          "components": {
            "self_confidence": 0.3,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7370402973570254
          },
          "reasoning": "The input points are integer grid coordinates (lattice points), and the solution exploits integer arithmetic to avoid floating-point precision issues, which relates to lattice‐point geometry.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "ROT": {
          "tag_name": "座標回転",
          "composite_confidence": 0.22761215763780746,
          "components": {
            "self_confidence": 0.05,
            "verifier_score": 0.0,
            "embedding_similarity": 0.6920405254593582
          },
          "reasoning": "Although this problem does not involve an explicit coordinate rotation, one might consider that checking collinearity could be framed in terms of rotating axes or vectors (but this is not used here).",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1324,
      "inferred_at": "2025-08-16T15:23:14.692785",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc181_d": {
      "contest_id": "abc181",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc181/tasks/abc181_d",
      "editorial_url": "https://atcoder.jp/contests/abc181/editorial/259",
      "editorial_id": 259,
      "tags": [
        "整数",
        "組み合わせ",
        "約数列挙"
      ],
      "tag_ids": [
        "INT",
        "CMB",
        "DIV"
      ],
      "confidence_scores": [
        0.8719086333715302,
        0.5927389047297977,
        0.3758072728962041
      ],
      "avg_confidence": 0.6134849369991774,
      "min_confidence": 0.3758072728962041,
      "confidence_std": 0.2030631073624798,
      "low_confidence": true,
      "detailed_confidence": {
        "INT": {
          "tag_name": "整数",
          "composite_confidence": 0.8719086333715302,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 1.0,
            "embedding_similarity": 0.706362111238434
          },
          "reasoning": "8の倍数判定や文字列→整数変換，桁による剰余判定など，純粋に整数に関する処理が中心であるため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CMB": {
          "tag_name": "組み合わせ",
          "composite_confidence": 0.5927389047297977,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7091296824326591
          },
          "reasoning": "問題の本質は文字列中の数字の順列（組み合わせ）を試して8の倍数を作れるか調べることであり、入力の桁の選び方を組み合わせ的に扱っているため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DIV": {
          "tag_name": "約数列挙",
          "composite_confidence": 0.3758072728962041,
          "components": {
            "self_confidence": 0.4,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7193575763206801
          },
          "reasoning": "厳密には約数列挙ではなく8の倍数を列挙しているが，ある種の整数列（8の倍数）を全探索している点で近い要素があるため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1340,
      "inferred_at": "2025-08-16T15:23:25.173035",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc181_e": {
      "contest_id": "abc181",
      "problem_index": "E",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc181/tasks/abc181_e",
      "editorial_url": "https://atcoder.jp/contests/abc181/editorial/261",
      "editorial_id": 261,
      "tags": [
        "二部マッチング",
        "写像12相",
        "組み合わせ"
      ],
      "tag_ids": [
        "BPM",
        "MAP",
        "CMB"
      ],
      "confidence_scores": [
        0.5382037087172218,
        0.41131790372331384,
        0.24890956925995666
      ],
      "avg_confidence": 0.39947706056683074,
      "min_confidence": 0.24890956925995666,
      "confidence_std": 0.11840025043912762,
      "low_confidence": true,
      "detailed_confidence": {
        "BPM": {
          "tag_name": "二部マッチング",
          "composite_confidence": 0.5382037087172218,
          "components": {
            "self_confidence": 0.8,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7273456957240723
          },
          "reasoning": "The problem reduces to matching teachers (or transformed teachers) with students in pairs to minimize total height difference, i.e. a special case of a weighted bipartite matching that is solved greedily on a sorted list.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MAP": {
          "tag_name": "写像12相",
          "composite_confidence": 0.41131790372331384,
          "components": {
            "self_confidence": 0.5,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7043930124110461
          },
          "reasoning": "You maintain a sorted array H of heights and for each transform w you insert w via binary search at the correct position; conceptually this uses map-like insertion/lookup operations on a sorted sequence.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CMB": {
          "tag_name": "組み合わせ",
          "composite_confidence": 0.24890956925995666,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.6963652308665222
          },
          "reasoning": "Although the main solution is not combinatorial counting, one could view the pairing choices among N+1 items as a combinatorial pairing problem, albeit here solved deterministically by sorting and greedy pairing.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1228,
      "inferred_at": "2025-08-16T15:23:40.945905",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc181_f": {
      "contest_id": "abc181",
      "problem_index": "F",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc181/tasks/abc181_f",
      "editorial_url": "https://atcoder.jp/contests/abc181/editorial/267",
      "editorial_id": 267,
      "tags": [
        "幾何",
        "グラフ",
        "区間スケジューリング"
      ],
      "tag_ids": [
        "GEO",
        "GRP",
        "SCH"
      ],
      "confidence_scores": [
        0.9144774863166241,
        0.8955791840928271,
        0.26597641561517094
      ],
      "avg_confidence": 0.692011028674874,
      "min_confidence": 0.26597641561517094,
      "confidence_std": 0.3013507426022969,
      "low_confidence": true,
      "detailed_confidence": {
        "GEO": {
          "tag_name": "幾何",
          "composite_confidence": 0.9144774863166241,
          "components": {
            "self_confidence": 0.99,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7282582877220806
          },
          "reasoning": "問題文では平面上の点、直線間の距離計算や円の通過可否など純粋な幾何計算を扱っているため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "GRP": {
          "tag_name": "グラフ",
          "composite_confidence": 0.8955791840928271,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7185972803094239
          },
          "reasoning": "頂点を点・直線、距離制約で辺を張り連結成分を調べるグラフ構築・DSU／Kruskal的アルゴリズムが中心のため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "SCH": {
          "tag_name": "区間スケジューリング",
          "composite_confidence": 0.26597641561517094,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7532547187172365
          },
          "reasoning": "エッジを距離の短い順に加えていく貪欲法はスケジューリング的手法に似るが，本質的にはMST的グラフアルゴリズムなので関連は薄いと判断したため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1097,
      "inferred_at": "2025-08-16T15:23:38.816323",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc182_c": {
      "contest_id": "abc182",
      "problem_index": "C",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc182/tasks/abc182_c",
      "editorial_url": "https://atcoder.jp/contests/abc182/editorial/290",
      "editorial_id": 290,
      "tags": [
        "整数",
        "約数列挙",
        "ビット演算"
      ],
      "tag_ids": [
        "INT",
        "DIV",
        "BOP"
      ],
      "confidence_scores": [
        0.8975783361634596,
        0.34089470549466905,
        0.24090092283385905
      ],
      "avg_confidence": 0.49312465483066253,
      "min_confidence": 0.24090092283385905,
      "confidence_std": 0.2888907225929822,
      "low_confidence": true,
      "detailed_confidence": {
        "INT": {
          "tag_name": "整数",
          "composite_confidence": 0.8975783361634596,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7252611205448657
          },
          "reasoning": "The problem is fundamentally about properties of integers, specifically manipulating digits and using modulo arithmetic to determine divisibility by 3.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DIV": {
          "tag_name": "約数列挙",
          "composite_confidence": 0.34089470549466905,
          "components": {
            "self_confidence": 0.3,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7363156849822301
          },
          "reasoning": "Although the tag DIV typically refers to divisor enumeration, here the core idea revolves around divisibility by 3, so there is a loose connection to divisibility concepts.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BOP": {
          "tag_name": "ビット演算",
          "composite_confidence": 0.24090092283385905,
          "components": {
            "self_confidence": 0.05,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7363364094461969
          },
          "reasoning": "There is no bitwise operation in the problem; this tag is included only to meet the requirement of selecting three tags and has very low relevance.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 2195,
      "inferred_at": "2025-08-16T15:23:43.567438",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc182_d": {
      "contest_id": "abc182",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc182/tasks/abc182_d",
      "editorial_url": "https://atcoder.jp/contests/abc182/editorial/291",
      "editorial_id": 291,
      "tags": [
        "DP",
        "最適化",
        "組み合わせ"
      ],
      "tag_ids": [
        "DP",
        "OPT",
        "CMB"
      ],
      "confidence_scores": [
        0.5855708251643995,
        0.5335392663801602,
        0.25337532889016473
      ],
      "avg_confidence": 0.45749514014490816,
      "min_confidence": 0.25337532889016473,
      "confidence_std": 0.14588921318905773,
      "low_confidence": true,
      "detailed_confidence": {
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.5855708251643995,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7519027505479983
          },
          "reasoning": "The core computation is done by iteratively building p_i and q_i via recurrence (prefix sums and prefix‐max), which is a basic 1D DP over i.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "OPT": {
          "tag_name": "最適化",
          "composite_confidence": 0.5335392663801602,
          "components": {
            "self_confidence": 0.8,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7117975546005341
          },
          "reasoning": "The task is to optimize a naive O(N²) simulation down to O(N) by precomputing and aggregating prefix data efficiently.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CMB": {
          "tag_name": "組み合わせ",
          "composite_confidence": 0.25337532889016473,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7112510963005491
          },
          "reasoning": "No real combinatorial enumeration is involved; this tag is included only to meet the requirement of three tags with low confidence.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 852,
      "inferred_at": "2025-08-16T15:24:10.985146",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc182_e": {
      "contest_id": "abc182",
      "problem_index": "E",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc182/tasks/abc182_e",
      "editorial_url": "https://atcoder.jp/contests/abc182/editorial/292",
      "editorial_id": 292,
      "tags": [
        "Imos法",
        "平方分割",
        "Mo's algorithm"
      ],
      "tag_ids": [
        "IMO",
        "SQD",
        "MOS"
      ],
      "confidence_scores": [
        0.593559071546989,
        0.2640176662417763,
        0.24609298234953095
      ],
      "avg_confidence": 0.3678899067127654,
      "min_confidence": 0.24609298234953095,
      "confidence_std": 0.1597398980444798,
      "low_confidence": true,
      "detailed_confidence": {
        "IMO": {
          "tag_name": "Imos法",
          "composite_confidence": 0.593559071546989,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 0.1,
            "embedding_similarity": 0.678530238489963
          },
          "reasoning": "本問題は各光源からの光の届く区間を行・列ごとにまとめて範囲加算し，最後にセルごとに累積和を見て光の当たるかどうか判定できるため，いわゆるImos法（累積和による範囲更新）が適用可能です。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "SQD": {
          "tag_name": "平方分割",
          "composite_confidence": 0.2640176662417763,
          "components": {
            "self_confidence": 0.15,
            "verifier_score": 0.0,
            "embedding_similarity": 0.6800588874725877
          },
          "reasoning": "行方向と列方向に処理を分割し，それぞれを走査することで全体の計算量を抑えている点で，“2次元のループを分割”する平方分割的な発想に近いとも言えます（自信は低め）。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MOS": {
          "tag_name": "Mo's algorithm",
          "composite_confidence": 0.24609298234953095,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.6869766078317698
          },
          "reasoning": "オフラインでの区間更新・クエリ処理アルゴリズム（Mo’s algorithm）とは直接関係しませんが，複数の光源による重複更新を抑える工夫という点で似た“不要な再走査を避ける”発想があるため，可能性として挙げました（自信は低め）。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 800,
      "inferred_at": "2025-08-16T15:24:06.446744",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc182_f": {
      "contest_id": "abc182",
      "problem_index": "F",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc182/tasks/abc182_f",
      "editorial_url": "https://atcoder.jp/contests/abc182/editorial/293",
      "editorial_id": 293,
      "tags": [
        "DP",
        "桁DP",
        "組み合わせ"
      ],
      "tag_ids": [
        "DP",
        "KDP",
        "CMB"
      ],
      "confidence_scores": [
        0.9028213982498179,
        0.5254749066075638,
        0.25680959710536283
      ],
      "avg_confidence": 0.5617019673209148,
      "min_confidence": 0.25680959710536283,
      "confidence_std": 0.2649743531619898,
      "low_confidence": true,
      "detailed_confidence": {
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.9028213982498179,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7427379941660599
          },
          "reasoning": "The core solution is formulated as a dynamic programming over index i and possible states j, counting the number of valid sequences. This is a classical DP approach.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "KDP": {
          "tag_name": "桁DP",
          "composite_confidence": 0.5254749066075638,
          "components": {
            "self_confidence": 0.75,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7515830220252124
          },
          "reasoning": "The DP iterates over the digits x_i in a mixed-radix representation with bounds determined by A_{i+1}/A_i, resembling a digit-DP (桁DP) pattern.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CMB": {
          "tag_name": "組み合わせ",
          "composite_confidence": 0.25680959710536283,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7226986570178761
          },
          "reasoning": "Although the problem counts combinations of coin contributions, it relies on DP rather than direct combinatorial formulas. This tag is less central but acknowledges the counting aspect.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1255,
      "inferred_at": "2025-08-16T15:24:09.163485",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc183_c": {
      "contest_id": "abc183",
      "problem_index": "C",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc183/tasks/abc183_c",
      "editorial_url": "https://atcoder.jp/contests/abc183/editorial/286",
      "editorial_id": 286,
      "tags": [
        "全列挙",
        "全探索",
        "半分全列挙"
      ],
      "tag_ids": [
        "ENM",
        "BRT",
        "MIT"
      ],
      "confidence_scores": [
        0.9013431826214159,
        0.895175063440522,
        0.2370560558704985
      ],
      "avg_confidence": 0.6778581006441454,
      "min_confidence": 0.2370560558704985,
      "confidence_std": 0.3117042866040703,
      "low_confidence": true,
      "detailed_confidence": {
        "ENM": {
          "tag_name": "全列挙",
          "composite_confidence": 0.9013431826214159,
          "components": {
            "self_confidence": 0.98,
            "verifier_score": 1.0,
            "embedding_similarity": 0.6978106087380531
          },
          "reasoning": "問題では都市の訪問順序をすべて列挙して解く全列挙 (enumeration) アプローチを用いており、“全列挙” タグが最適です。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BRT": {
          "tag_name": "全探索",
          "composite_confidence": 0.895175063440522,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7172502114684067
          },
          "reasoning": "全ての順序を試す全探索 (brute force) 手法であるため、“全探索” タグが適切です。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MIT": {
          "tag_name": "半分全列挙",
          "composite_confidence": 0.2370560558704985,
          "components": {
            "self_confidence": 0.05,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7235201862349949
          },
          "reasoning": "半分全列挙（meet-in-the-middle）の手法は用いられていませんが、3つ目のタグ要件を満たすダミーとして最も近い概念として挙げています。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 621,
      "inferred_at": "2025-08-16T15:24:23.088206",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc183_d": {
      "contest_id": "abc183",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc183/tasks/abc183_d",
      "editorial_url": "https://atcoder.jp/contests/abc183/editorial/284",
      "editorial_id": 284,
      "tags": [
        "最適化",
        "半分全列挙",
        "DP"
      ],
      "tag_ids": [
        "OPT",
        "MIT",
        "DP"
      ],
      "confidence_scores": [
        0.571166288699741,
        0.23115604038950116,
        0.22951930108864121
      ],
      "avg_confidence": 0.3439472100592944,
      "min_confidence": 0.22951930108864121,
      "confidence_std": 0.16066954078178564,
      "low_confidence": true,
      "detailed_confidence": {
        "OPT": {
          "tag_name": "最適化",
          "composite_confidence": 0.571166288699741,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7038876289991365
          },
          "reasoning": "問題の本質は時刻ごとにお湯の使用量を求めるO(NT)のシミュレーションを、いもす法（差分→累積和）を用いてO(N+T)に最適化する点にあるため、最適化(OPT)が最も適切です。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MIT": {
          "tag_name": "半分全列挙",
          "composite_confidence": 0.23115604038950116,
          "components": {
            "self_confidence": 0.05,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7038534679650038
          },
          "reasoning": "半分全列挙(MIT)は使われておらず無関係ですが、要件に合わせ候補として挙げています。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.22951930108864121,
          "components": {
            "self_confidence": 0.05,
            "verifier_score": 0.0,
            "embedding_similarity": 0.6983976702954707
          },
          "reasoning": "累積和により状態を更新していく点で動的計画法的な要素とも捉えられますが、本質はDPではないため低めの確信度です。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 838,
      "inferred_at": "2025-08-16T15:24:31.393204",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc183_e": {
      "contest_id": "abc183",
      "problem_index": "E",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc183/tasks/abc183_e",
      "editorial_url": "https://atcoder.jp/contests/abc183/editorial/179",
      "editorial_id": 179,
      "tags": [
        "DP",
        "桁DP",
        "bitDP"
      ],
      "tag_ids": [
        "DP",
        "KDP",
        "BDP"
      ],
      "confidence_scores": [
        0.9221128557308228,
        0.239921217856881,
        0.23359054413765842
      ],
      "avg_confidence": 0.4652082059084541,
      "min_confidence": 0.23359054413765842,
      "confidence_std": 0.32309071340147477,
      "low_confidence": true,
      "detailed_confidence": {
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.9221128557308228,
          "components": {
            "self_confidence": 0.98,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7670428524360762
          },
          "reasoning": "この問題は累積和を用いて2次元グリッド上で移動の通り数を数える典型的な動的計画法(DP)問題であり，DPによる解法が中心となっているため",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "KDP": {
          "tag_name": "桁DP",
          "composite_confidence": 0.239921217856881,
          "components": {
            "self_confidence": 0.01,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7864040595229367
          },
          "reasoning": "桁DPは数の各桁を扱うDPであり，本問題のグリッド移動とは無関係のため極めて可能性が低いタグとして設定",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BDP": {
          "tag_name": "bitDP",
          "composite_confidence": 0.23359054413765842,
          "components": {
            "self_confidence": 0.01,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7653018137921948
          },
          "reasoning": "bitDPは集合全列挙やビットを用いたDPであり，本問題の累積和DPとは無関係のため可能性が低いタグとして設定",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1232,
      "inferred_at": "2025-08-16T15:24:30.805743",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc183_f": {
      "contest_id": "abc183",
      "problem_index": "F",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc183/tasks/abc183_f",
      "editorial_url": "https://atcoder.jp/contests/abc183/editorial/282",
      "editorial_id": 282,
      "tags": [
        "Union Find",
        "写像12相",
        "半分全列挙"
      ],
      "tag_ids": [
        "UF",
        "MAP",
        "MIT"
      ],
      "confidence_scores": [
        0.9140684776382586,
        0.5935452258576566,
        0.22643213694618244
      ],
      "avg_confidence": 0.5780152801473658,
      "min_confidence": 0.22643213694618244,
      "confidence_std": 0.28094105985707,
      "low_confidence": true,
      "detailed_confidence": {
        "UF": {
          "tag_name": "Union Find",
          "composite_confidence": 0.9140684776382586,
          "components": {
            "self_confidence": 0.99,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7268949254608621
          },
          "reasoning": "問題の主軸は各生徒の集団管理にUnion-Find(UF)を使い，クエリで属する集団を高速に求めているため．",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MAP": {
          "tag_name": "写像12相",
          "composite_confidence": 0.5935452258576566,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7118174195255217
          },
          "reasoning": "各クラスの人数を保持・マージするためにmap/dictを使い，小さい方から大きい方へ要素を移す技法を用いているため．",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MIT": {
          "tag_name": "半分全列挙",
          "composite_confidence": 0.22643213694618244,
          "components": {
            "self_confidence": 0.01,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7414404564872749
          },
          "reasoning": "候補タグの中に第三の明確な技法が見当たらないため，無関係なMITを最低限の信頼度で挙げています．",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1103,
      "inferred_at": "2025-08-16T15:24:42.452727",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc184_c": {
      "contest_id": "abc184",
      "problem_index": "C",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc184/tasks/abc184_c",
      "editorial_url": "https://atcoder.jp/contests/abc184/editorial/339",
      "editorial_id": 339,
      "tags": [
        "DP",
        "中国剰余定理",
        "ゲーム"
      ],
      "tag_ids": [
        "DP",
        "CRT",
        "GAM"
      ],
      "confidence_scores": [
        0.5707075144868585,
        0.36717517376542325,
        0.2504028517814137
      ],
      "avg_confidence": 0.39609518001123184,
      "min_confidence": 0.2504028517814137,
      "confidence_std": 0.1323531747727909,
      "low_confidence": true,
      "detailed_confidence": {
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.5707075144868585,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7023583816228617
          },
          "reasoning": "The solution determines the minimum number of moves (0–3) by systematically checking cases and is analogous to a shortest‐path DP/BFS over the implicit move graph.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CRT": {
          "tag_name": "中国剰余定理",
          "composite_confidence": 0.36717517376542325,
          "components": {
            "self_confidence": 0.4,
            "verifier_score": 0.0,
            "embedding_similarity": 0.6905839125514107
          },
          "reasoning": "A key step uses parity checks ((a+b+c+d) mod 2), which invokes simple modular arithmetic reasoning akin to CRT techniques.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "GAM": {
          "tag_name": "ゲーム",
          "composite_confidence": 0.2504028517814137,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.701342839271379
          },
          "reasoning": "The problem describes movements A, B, C on a grid, resembling moves in a combinatorial game, though there is no adversarial component.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1739,
      "inferred_at": "2025-08-16T15:24:54.248356",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc184_d": {
      "contest_id": "abc184",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc184/tasks/abc184_d",
      "editorial_url": "https://atcoder.jp/contests/abc184/editorial/152",
      "editorial_id": 152,
      "tags": [
        "確率/期待値DP",
        "DP",
        "組み合わせ"
      ],
      "tag_ids": [
        "EDP",
        "DP",
        "CMB"
      ],
      "confidence_scores": [
        0.9125212040604773,
        0.8712354037138911,
        0.24878027761298352
      ],
      "avg_confidence": 0.6775122951291173,
      "min_confidence": 0.24878027761298352,
      "confidence_std": 0.3036274981619807,
      "low_confidence": true,
      "detailed_confidence": {
        "EDP": {
          "tag_name": "確率/期待値DP",
          "composite_confidence": 0.9125212040604773,
          "components": {
            "self_confidence": 0.98,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7350706802015912
          },
          "reasoning": "問題文中で確率DP（期待値DP）と明示されており，状態遷移式も確率による期待値計算となっているため．",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.8712354037138911,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7041180123796369
          },
          "reasoning": "再帰的にf(X,Y,Z)をメモ化再帰やテーブルDPで計算する典型的な動的計画法の問題であるため．",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CMB": {
          "tag_name": "組み合わせ",
          "composite_confidence": 0.24878027761298352,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.6959342587099451
          },
          "reasoning": "直接的な組み合わせ計算は用いられておらず，組み合わせ論的要素は薄いため低めの自信度で．",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 646,
      "inferred_at": "2025-08-16T15:24:48.714300",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc184_e": {
      "contest_id": "abc184",
      "problem_index": "E",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc184/tasks/abc184_e",
      "editorial_url": "https://atcoder.jp/contests/abc184/editorial/352",
      "editorial_id": 352,
      "tags": [
        "BFS",
        "0-1 BFS",
        "全探索"
      ],
      "tag_ids": [
        "BFS",
        "01B",
        "BRT"
      ],
      "confidence_scores": [
        0.8802601895523089,
        0.8565460073445812,
        0.2840736640720859
      ],
      "avg_confidence": 0.673626620322992,
      "min_confidence": 0.2840736640720859,
      "confidence_std": 0.2756256155274283,
      "low_confidence": true,
      "detailed_confidence": {
        "BFS": {
          "tag_name": "BFS",
          "composite_confidence": 0.8802601895523089,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7342006318410296
          },
          "reasoning": "Editorial centers on performing breadth-first search on the grid, optimizing teleporter connections to achieve O(HW) time.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "01B": {
          "tag_name": "0-1 BFS",
          "composite_confidence": 0.8565460073445812,
          "components": {
            "self_confidence": 0.85,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7218200244819373
          },
          "reasoning": "An alternative solution uses 0-1 BFS with super‐vertices for teleporters, assigning cost 1 and 0 edges to achieve the same complexity.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BRT": {
          "tag_name": "全探索",
          "composite_confidence": 0.2840736640720859,
          "components": {
            "self_confidence": 0.15,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7469122135736196
          },
          "reasoning": "The naive approach of connecting all teleporter pairs by brute-force BFS is discussed (and shown to TLE), but not used in the final solution.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 841,
      "inferred_at": "2025-08-16T15:25:02.388184",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc184_f": {
      "contest_id": "abc184",
      "problem_index": "F",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc184/tasks/abc184_f",
      "editorial_url": "https://atcoder.jp/contests/abc184/editorial/354",
      "editorial_id": 354,
      "tags": [
        "半分全列挙",
        "全列挙",
        "全探索"
      ],
      "tag_ids": [
        "MIT",
        "ENM",
        "BRT"
      ],
      "confidence_scores": [
        0.9274998031992588,
        0.837931877880986,
        0.8015975120559184
      ],
      "avg_confidence": 0.8556763977120544,
      "min_confidence": 0.8015975120559184,
      "confidence_std": 0.05290871205395194,
      "low_confidence": false,
      "detailed_confidence": {
        "MIT": {
          "tag_name": "半分全列挙",
          "composite_confidence": 0.9274998031992588,
          "components": {
            "self_confidence": 0.98,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7849993439975298
          },
          "reasoning": "The editorial explicitly describes the meet-in-the-middle (半分全列挙) technique, splitting the array into two halves, enumerating subset sums for each, and combining via binary search.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "ENM": {
          "tag_name": "全列挙",
          "composite_confidence": 0.837931877880986,
          "components": {
            "self_confidence": 0.8,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7264395929366196
          },
          "reasoning": "The solution involves full enumeration of subset sums for each half; it’s a classic example of enumeration (全列挙) over 2^(N/2) subsets.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BRT": {
          "tag_name": "全探索",
          "composite_confidence": 0.8015975120559184,
          "components": {
            "self_confidence": 0.7,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7386583735197283
          },
          "reasoning": "Although optimized by meet-in-the-middle, the method still relies on brute-force exploration of all subset combinations in each half—i.e., full search (全探索).",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1300,
      "inferred_at": "2025-08-16T15:25:07.731972",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc185_c": {
      "contest_id": "abc185",
      "problem_index": "C",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc185/tasks/abc185_c",
      "editorial_url": "https://atcoder.jp/contests/abc185/editorial/358",
      "editorial_id": 358,
      "tags": [
        "素因数分解",
        "約数列挙",
        "半分全列挙"
      ],
      "tag_ids": [
        "PFT",
        "DIV",
        "MIT"
      ],
      "confidence_scores": [
        0.5828649634835783,
        0.29970263429754707,
        0.2461341867134288
      ],
      "avg_confidence": 0.3762339281648514,
      "min_confidence": 0.2461341867134288,
      "confidence_std": 0.14773779297979203,
      "low_confidence": true,
      "detailed_confidence": {
        "PFT": {
          "tag_name": "素因数分解",
          "composite_confidence": 0.5828649634835783,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7428832116119275
          },
          "reasoning": "問題の核心は二項係数 C(L−1,11) をオーバーフローせずに計算する方法にあり、分子・分母を素因数分解して約分する手法が典型的なアプローチだから。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DIV": {
          "tag_name": "約数列挙",
          "composite_confidence": 0.29970263429754707,
          "components": {
            "self_confidence": 0.2,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7323421143251567
          },
          "reasoning": "分数計算でオーバーフローを避けるために、分子と分母の最大公約数で除算しながら進める実装上の工夫があるため。ただし主手法ではない。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MIT": {
          "tag_name": "半分全列挙",
          "composite_confidence": 0.2461341867134288,
          "components": {
            "self_confidence": 0.05,
            "verifier_score": 0.0,
            "embedding_similarity": 0.753780622378096
          },
          "reasoning": "切る位置を選ぶ組み合わせの数を求める点で列挙的な手法（半分全列挙）と対比はできるが、本問題では使われていないため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1708,
      "inferred_at": "2025-08-16T15:25:14.475933",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc185_d": {
      "contest_id": "abc185",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc185/tasks/abc185_d",
      "editorial_url": "https://atcoder.jp/contests/abc185/editorial/357",
      "editorial_id": 357,
      "tags": [
        "最適化",
        "全探索",
        "半分全列挙"
      ],
      "tag_ids": [
        "OPT",
        "BRT",
        "MIT"
      ],
      "confidence_scores": [
        0.8701451069297115,
        0.2911457739762158,
        0.25482887854878467
      ],
      "avg_confidence": 0.4720399198182373,
      "min_confidence": 0.25482887854878467,
      "confidence_std": 0.2818930461802468,
      "low_confidence": true,
      "detailed_confidence": {
        "OPT": {
          "tag_name": "最適化",
          "composite_confidence": 0.8701451069297115,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 1.0,
            "embedding_similarity": 0.700483689765705
          },
          "reasoning": "This problem relies on finding the optimal stamp width k by exploiting a monotonicity property and then computing the minimal number of stamps, which is a classic optimization/greedy scenario.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BRT": {
          "tag_name": "全探索",
          "composite_confidence": 0.2911457739762158,
          "components": {
            "self_confidence": 0.2,
            "verifier_score": 0.0,
            "embedding_similarity": 0.703819246587386
          },
          "reasoning": "The solution involves enumerating contiguous white‐cell segments and computing values for each, which at its core is a simple brute‐force scan (O(M)).",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MIT": {
          "tag_name": "半分全列挙",
          "composite_confidence": 0.25482887854878467,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7160962618292823
          },
          "reasoning": "While not a true meet-in-the-middle, one might loosely consider splitting the problem into analyzing individual segments before combining results, but this is a weak connection.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 768,
      "inferred_at": "2025-08-16T15:25:29.351447",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc185_e": {
      "contest_id": "abc185",
      "problem_index": "E",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc185/tasks/abc185_e",
      "editorial_url": "https://atcoder.jp/contests/abc185/editorial/356",
      "editorial_id": 356,
      "tags": [
        "編集距離",
        "DP",
        "LCP"
      ],
      "tag_ids": [
        "EDT",
        "DP",
        "LCP"
      ],
      "confidence_scores": [
        0.8968892430285409,
        0.87721292106561,
        0.2372878997052068
      ],
      "avg_confidence": 0.6704633545997859,
      "min_confidence": 0.2372878997052068,
      "confidence_std": 0.3064066148696765,
      "low_confidence": true,
      "detailed_confidence": {
        "EDT": {
          "tag_name": "編集距離",
          "composite_confidence": 0.8968892430285409,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7229641434284698
          },
          "reasoning": "The DP recurrence given is exactly the classic Levenshtein (edit) distance formulation, matching the 編集距離 tag.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.87721292106561,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7240430702187
          },
          "reasoning": "The problem is solved by filling a 2D dp table over prefixes of the two sequences, a straightforward dynamic programming approach.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "LCP": {
          "tag_name": "LCP",
          "composite_confidence": 0.2372878997052068,
          "components": {
            "self_confidence": 0.05,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7242929990173561
          },
          "reasoning": "Only remote relevance: the dp operates on prefixes, but this is not genuinely a longest-common-prefix problem; included to satisfy the three-tag requirement.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 868,
      "inferred_at": "2025-08-16T15:25:28.033731",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc185_f": {
      "contest_id": "abc185",
      "problem_index": "F",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc185/tasks/abc185_f",
      "editorial_url": "https://atcoder.jp/contests/abc185/editorial/355",
      "editorial_id": 355,
      "tags": [
        "XOR",
        "Fenwick Tree(BIT)",
        "セグメント木"
      ],
      "tag_ids": [
        "XOR",
        "BIT",
        "SEG"
      ],
      "confidence_scores": [
        0.9293592710664278,
        0.8850133287172324,
        0.6082869325106472
      ],
      "avg_confidence": 0.8075531774314358,
      "min_confidence": 0.6082869325106472,
      "confidence_std": 0.14206082716999155,
      "low_confidence": false,
      "detailed_confidence": {
        "XOR": {
          "tag_name": "XOR",
          "composite_confidence": 0.9293592710664278,
          "components": {
            "self_confidence": 1.0,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7645309035547594
          },
          "reasoning": "The problem’s core operation is the bitwise XOR, and the solution exploits properties of XOR (associativity, 0 as identity).",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BIT": {
          "tag_name": "Fenwick Tree(BIT)",
          "composite_confidence": 0.8850133287172324,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7500444290574414
          },
          "reasoning": "The editorial explicitly describes using a Fenwick Tree (BIT) to maintain prefix XORs for O(log N) queries.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "SEG": {
          "tag_name": "セグメント木",
          "composite_confidence": 0.6082869325106472,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 0.1,
            "embedding_similarity": 0.7276231083688243
          },
          "reasoning": "Alternatively, the editorial also suggests a segment tree for range XOR queries with O(log N) complexity.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 637,
      "inferred_at": "2025-08-16T15:25:32.216514",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc186_d": {
      "contest_id": "abc186",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc186/tasks/abc186_d",
      "editorial_url": "https://atcoder.jp/contests/abc186/editorial/402",
      "editorial_id": 402,
      "tags": [
        "累積和",
        "半分全列挙",
        "区間スケジューリング"
      ],
      "tag_ids": [
        "CUM",
        "MIT",
        "SCH"
      ],
      "confidence_scores": [
        0.8981850540957422,
        0.2378971900242135,
        0.23111926265295585
      ],
      "avg_confidence": 0.4557338355909705,
      "min_confidence": 0.23111926265295585,
      "confidence_std": 0.3128724933495331,
      "low_confidence": true,
      "detailed_confidence": {
        "CUM": {
          "tag_name": "累積和",
          "composite_confidence": 0.8981850540957422,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7272835136524743
          },
          "reasoning": "The solution explicitly computes prefix (cumulative) sums of the sorted array and uses them to get each |A_i-A_j| sum in O(1). This is a direct application of 累積和.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MIT": {
          "tag_name": "半分全列挙",
          "composite_confidence": 0.2378971900242135,
          "components": {
            "self_confidence": 0.05,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7263239667473784
          },
          "reasoning": "Meet-in-the-middle is not used in the editorial; this tag is unlikely and only chosen to fill the three-tag requirement.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "SCH": {
          "tag_name": "区間スケジューリング",
          "composite_confidence": 0.23111926265295585,
          "components": {
            "self_confidence": 0.05,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7037308755098528
          },
          "reasoning": "Interval scheduling is not related to computing pairwise differences; this is chosen with low confidence to complete the tag list.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 538,
      "inferred_at": "2025-08-16T15:25:46.664891",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc186_e": {
      "contest_id": "abc186",
      "problem_index": "E",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc186/tasks/abc186_e",
      "editorial_url": "https://atcoder.jp/contests/abc186/editorial/401",
      "editorial_id": 401,
      "tags": [
        "GCD",
        "ユークリッドの互除法",
        "中国剰余定理"
      ],
      "tag_ids": [
        "GCD",
        "EUC",
        "CRT"
      ],
      "confidence_scores": [
        0.8793837287295422,
        0.8725704476127543,
        0.32456734821885774
      ],
      "avg_confidence": 0.6921738415203847,
      "min_confidence": 0.32456734821885774,
      "confidence_std": 0.2599519258606333,
      "low_confidence": true,
      "detailed_confidence": {
        "GCD": {
          "tag_name": "GCD",
          "composite_confidence": 0.8793837287295422,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7312790957651404
          },
          "reasoning": "The solution begins by computing d = gcd(A,B,M) and reducing the equation by this gcd, so gcd computation is central.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "EUC": {
          "tag_name": "ユークリッドの互除法",
          "composite_confidence": 0.8725704476127543,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7085681587091807
          },
          "reasoning": "Finding the modular inverse A^{-1} mod M uses the extended Euclidean algorithm (EUC).",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CRT": {
          "tag_name": "中国剰余定理",
          "composite_confidence": 0.32456734821885774,
          "components": {
            "self_confidence": 0.2,
            "verifier_score": 0.1,
            "embedding_similarity": 0.7152244940628592
          },
          "reasoning": "Though the problem deals with a single modular equation rather than a system, CRT is only lightly related and not actually used. This tag is less applicable.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 705,
      "inferred_at": "2025-08-16T15:25:46.206222",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc186_f": {
      "contest_id": "abc186",
      "problem_index": "F",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc186/tasks/abc186_f",
      "editorial_url": "https://atcoder.jp/contests/abc186/editorial/400",
      "editorial_id": 400,
      "tags": [
        "全探索",
        "写像12相",
        "半分全列挙"
      ],
      "tag_ids": [
        "BRT",
        "MAP",
        "MIT"
      ],
      "confidence_scores": [
        0.5564003046383998,
        0.4512396512664998,
        0.33668774336122975
      ],
      "avg_confidence": 0.44810923308870976,
      "min_confidence": 0.33668774336122975,
      "confidence_std": 0.08972458612970187,
      "low_confidence": true,
      "detailed_confidence": {
        "BRT": {
          "tag_name": "全探索",
          "composite_confidence": 0.5564003046383998,
          "components": {
            "self_confidence": 0.85,
            "verifier_score": 0.0,
            "embedding_similarity": 0.721334348794666
          },
          "reasoning": "The solution effectively brute‐forces over rows (or columns) while using a data structure (Fenwick tree / segment tree) to maintain active columns, resulting in O((H+M) log W) time which is a form of optimized brute force enumeration.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MAP": {
          "tag_name": "写像12相",
          "composite_confidence": 0.4512396512664998,
          "components": {
            "self_confidence": 0.6,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7041321708883327
          },
          "reasoning": "We map each column to the position of its nearest obstacle (and track seen obstacles per column) using arrays or dictionaries, which is a key step in the implementation.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MIT": {
          "tag_name": "半分全列挙",
          "composite_confidence": 0.33668774336122975,
          "components": {
            "self_confidence": 0.3,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7222924778707658
          },
          "reasoning": "The problem splits the rook’s path into two independent segments (down→right and right→down) and combines their results, resembling a meet‐in‐the‐middle decomposition, though it doesn’t perform a classic meet‐in‐the‐middle search.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 742,
      "inferred_at": "2025-08-16T15:25:55.830522",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc187_d": {
      "contest_id": "abc187",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc187/tasks/abc187_d",
      "editorial_url": "https://atcoder.jp/contests/abc187/editorial/486",
      "editorial_id": 486,
      "tags": [
        "区間スケジューリング",
        "DP",
        "組み合わせ"
      ],
      "tag_ids": [
        "SCH",
        "DP",
        "CMB"
      ],
      "confidence_scores": [
        0.4868276401035717,
        0.2891023972344867,
        0.24644486141748723
      ],
      "avg_confidence": 0.3407916329185152,
      "min_confidence": 0.24644486141748723,
      "confidence_std": 0.10472122639468419,
      "low_confidence": true,
      "detailed_confidence": {
        "SCH": {
          "tag_name": "区間スケジューリング",
          "composite_confidence": 0.4868276401035717,
          "components": {
            "self_confidence": 0.7,
            "verifier_score": 0.0,
            "embedding_similarity": 0.6894254670119058
          },
          "reasoning": "The solution uses a greedy strategy of selecting towns by descending value of (2A_i + B_i), akin to scheduling tasks by weight.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.2891023972344867,
          "components": {
            "self_confidence": 0.2,
            "verifier_score": 0.0,
            "embedding_similarity": 0.6970079907816222
          },
          "reasoning": "One might attempt a DP over subsets or knapsack-like choices of speeches, but the given solution is greedy, not DP.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CMB": {
          "tag_name": "組み合わせ",
          "composite_confidence": 0.24644486141748723,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.6881495380582907
          },
          "reasoning": "Selecting a subset of towns to achieve a target resembles a combination/knapsack problem, though the actual method is greedy rather than combinatorial enumeration.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1089,
      "inferred_at": "2025-08-16T15:26:04.964896",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc187_e": {
      "contest_id": "abc187",
      "problem_index": "E",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc187/tasks/abc187_e",
      "editorial_url": "https://atcoder.jp/contests/abc187/editorial/487",
      "editorial_id": 487,
      "tags": [
        "クエリ先読み",
        "HLD",
        "全探索"
      ],
      "tag_ids": [
        "QAH",
        "HLD",
        "BRT"
      ],
      "confidence_scores": [
        0.57240477197169,
        0.3722683211012976,
        0.25178989889887454
      ],
      "avg_confidence": 0.39882099732395404,
      "min_confidence": 0.25178989889887454,
      "confidence_std": 0.13223024785026385,
      "low_confidence": true,
      "detailed_confidence": {
        "QAH": {
          "tag_name": "クエリ先読み",
          "composite_confidence": 0.57240477197169,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7080159065723002
          },
          "reasoning": "編集では全てのクエリを「ある頂点の子孫に x を足す」形に帰着し，オフラインでまとめて処理しています．クエリ変換(先読み)の典型例です．",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "HLD": {
          "tag_name": "HLD",
          "composite_confidence": 0.3722683211012976,
          "components": {
            "self_confidence": 0.4,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7075610703376587
          },
          "reasoning": "部分木加算・累積和の考え方は，重み付き木に対して HLD＋セグ木／BIT で行う範囲更新・点取得と類似しており，代替解法として HLD が挙げられます．",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BRT": {
          "tag_name": "全探索",
          "composite_confidence": 0.25178989889887454,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7059663296629152
          },
          "reasoning": "全探索ではありませんが，DFS による累積和計算で全ノードを探索するので，ごく弱く全探索要素が含まれるとも言えます．",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 755,
      "inferred_at": "2025-08-16T15:26:18.191030",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc187_f": {
      "contest_id": "abc187",
      "problem_index": "F",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc187/tasks/abc187_f",
      "editorial_url": "https://atcoder.jp/contests/abc187/editorial/488",
      "editorial_id": 488,
      "tags": [
        "グラフ",
        "半分全列挙",
        "最小カット"
      ],
      "tag_ids": [
        "GRP",
        "MIT",
        "MNC2"
      ],
      "confidence_scores": [
        0.9037785652230426,
        0.45746817550342433,
        0.299856467341032
      ],
      "avg_confidence": 0.553701069355833,
      "min_confidence": 0.299856467341032,
      "confidence_std": 0.25576819253894584,
      "low_confidence": true,
      "detailed_confidence": {
        "GRP": {
          "tag_name": "グラフ",
          "composite_confidence": 0.9037785652230426,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7459285507434754
          },
          "reasoning": "The problem is fundamentally about an undirected graph, induced subgraphs, and checking for cliques.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MIT": {
          "tag_name": "半分全列挙",
          "composite_confidence": 0.45746817550342433,
          "components": {
            "self_confidence": 0.6,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7248939183447479
          },
          "reasoning": "The solution relies on exhaustive subset enumeration (sum_{S⊆V}2^{|S|}=3^N) which is a form of advanced subset‐enumeration (related to meet‐in‐the‐middle ideas).",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MNC2": {
          "tag_name": "最小カット",
          "composite_confidence": 0.299856467341032,
          "components": {
            "self_confidence": 0.2,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7328548911367733
          },
          "reasoning": "Although this is not a network flow/min‐cut problem, the DP splits the set S into two parts minimizing f(T)+f(S\\T), which loosely resembles a partition/cut minimization.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1320,
      "inferred_at": "2025-08-16T15:26:24.875261",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc188_d": {
      "contest_id": "abc188",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc188/tasks/abc188_d",
      "editorial_url": "https://atcoder.jp/contests/abc188/editorial/346",
      "editorial_id": 346,
      "tags": [
        "累積和",
        "最適化",
        "DP"
      ],
      "tag_ids": [
        "CUM",
        "OPT",
        "DP"
      ],
      "confidence_scores": [
        0.8801000566059094,
        0.48435429356794346,
        0.24300901291445984
      ],
      "avg_confidence": 0.5358211210294376,
      "min_confidence": 0.24300901291445984,
      "confidence_std": 0.26262504987742313,
      "low_confidence": true,
      "detailed_confidence": {
        "CUM": {
          "tag_name": "累積和",
          "composite_confidence": 0.8801000566059094,
          "components": {
            "self_confidence": 0.93,
            "verifier_score": 1.0,
            "embedding_similarity": 0.6936668553530314
          },
          "reasoning": "The core technique is using the imos method (累積和) to handle range‐add events efficiently by marking increases and decreases at endpoints and then doing a prefix sum or sweep‐line to reconstruct daily costs.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "OPT": {
          "tag_name": "最適化",
          "composite_confidence": 0.48435429356794346,
          "components": {
            "self_confidence": 0.62,
            "verifier_score": 0.1,
            "embedding_similarity": 0.687847645226478
          },
          "reasoning": "The solution optimizes the naive per‐day simulation (which would be too large) by sorting events and sweeping once in O(N log N) instead of iterating over every day, representing an optimization of the brute‐force approach.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.24300901291445984,
          "components": {
            "self_confidence": 0.08,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7033633763815328
          },
          "reasoning": "There is no true dynamic programming in this problem; I include it with low confidence only to fulfill the requirement of three tags.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1541,
      "inferred_at": "2025-08-16T15:26:33.783409",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc188_e": {
      "contest_id": "abc188",
      "problem_index": "E",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc188/tasks/abc188_e",
      "editorial_url": "https://atcoder.jp/contests/abc188/editorial/477",
      "editorial_id": 477,
      "tags": [
        "DAG",
        "DP",
        "貪欲法"
      ],
      "tag_ids": [
        "DAG",
        "DP",
        "GRD"
      ],
      "confidence_scores": [
        0.910145022101158,
        0.9074257614770946,
        0.5324755653050557
      ],
      "avg_confidence": 0.7833487829611028,
      "min_confidence": 0.5324755653050557,
      "confidence_std": 0.1773976269991779,
      "low_confidence": false,
      "detailed_confidence": {
        "DAG": {
          "tag_name": "DAG",
          "composite_confidence": 0.910145022101158,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7671500736705268
          },
          "reasoning": "The problem’s graph satisfies Xi<Yi which guarantees no cycles, so it is a Directed Acyclic Graph and we explicitly perform DP on this DAG.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.9074257614770946,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7580858715903158
          },
          "reasoning": "We compute dp[i] and propagate minima along the DAG edges to find the maximum profit, which is a classic dynamic programming on a graph.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "GRD": {
          "tag_name": "貪欲法",
          "composite_confidence": 0.5324755653050557,
          "components": {
            "self_confidence": 0.7,
            "verifier_score": 0.1,
            "embedding_similarity": 0.7415852176835191
          },
          "reasoning": "The second solution greedily picks cities in ascending order of gold price and uses BFS while skipping already visited nodes, embodying a greedy strategy to prune search space.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1209,
      "inferred_at": "2025-08-16T15:26:37.919482",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc189_b": {
      "contest_id": "abc189",
      "problem_index": "B",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc189/tasks/abc189_b",
      "editorial_url": "https://atcoder.jp/contests/abc189/editorial/532",
      "editorial_id": 532,
      "tags": [
        "整数",
        "ビット演算",
        "約数列挙"
      ],
      "tag_ids": [
        "INT",
        "BOP",
        "DIV"
      ],
      "confidence_scores": [
        0.603052731784798,
        0.21847330785454663,
        0.210549288308562
      ],
      "avg_confidence": 0.3440251093159689,
      "min_confidence": 0.210549288308562,
      "confidence_std": 0.18318875406318294,
      "low_confidence": true,
      "detailed_confidence": {
        "INT": {
          "tag_name": "整数",
          "composite_confidence": 0.603052731784798,
          "components": {
            "self_confidence": 0.99,
            "verifier_score": 0.0,
            "embedding_similarity": 0.6901757726159932
          },
          "reasoning": "The core of the problem is handling sums of alcohol volumes exactly with integer arithmetic (multiplying by 100 to avoid floating-point errors).",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BOP": {
          "tag_name": "ビット演算",
          "composite_confidence": 0.21847330785454663,
          "components": {
            "self_confidence": 0.01,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7149110261818221
          },
          "reasoning": "No bitwise operations are used, but this is the least unlikely tag among the remaining ones (very low confidence).",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DIV": {
          "tag_name": "約数列挙",
          "composite_confidence": 0.210549288308562,
          "components": {
            "self_confidence": 0.01,
            "verifier_score": 0.0,
            "embedding_similarity": 0.6884976276952067
          },
          "reasoning": "No divisor enumeration is involved; this tag is chosen just to fulfill the requirement of selecting three tags (very low confidence).",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 978,
      "inferred_at": "2025-08-16T15:26:56.377610",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc189_c": {
      "contest_id": "abc189",
      "problem_index": "C",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc189/tasks/abc189_c",
      "editorial_url": "https://atcoder.jp/contests/abc189/editorial/533",
      "editorial_id": 533,
      "tags": [
        "最適化",
        "セグメント木",
        "貪欲法"
      ],
      "tag_ids": [
        "OPT",
        "SEG",
        "GRD"
      ],
      "confidence_scores": [
        0.7635587784369408,
        0.6000921437044656,
        0.5797457898251919
      ],
      "avg_confidence": 0.6477989039888661,
      "min_confidence": 0.5797457898251919,
      "confidence_std": 0.0822749655250436,
      "low_confidence": false,
      "detailed_confidence": {
        "OPT": {
          "tag_name": "最適化",
          "composite_confidence": 0.7635587784369408,
          "components": {
            "self_confidence": 0.6,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7451959281231356
          },
          "reasoning": "The goal is to maximize the value x*(r-l+1) over all intervals, making this an optimization problem.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "SEG": {
          "tag_name": "セグメント木",
          "composite_confidence": 0.6000921437044656,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7336404790148854
          },
          "reasoning": "The editorial discusses using a segment tree (or sparse table) to compute range minimum queries, so the problem involves the segment tree data structure.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "GRD": {
          "tag_name": "貪欲法",
          "composite_confidence": 0.5797457898251919,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7324859660839727
          },
          "reasoning": "The optimal O(N) solution for the largest-rectangle problem uses a monotonic stack, which is a greedy-like one-pass algorithm to expand intervals.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 925,
      "inferred_at": "2025-08-16T15:26:59.179925",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc189_d": {
      "contest_id": "abc189",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc189/tasks/abc189_d",
      "editorial_url": "https://atcoder.jp/contests/abc189/editorial/537",
      "editorial_id": 537,
      "tags": [
        "組み合わせ",
        "条件判定",
        "全探索"
      ],
      "tag_ids": [
        "CMB",
        "JDG",
        "BRT"
      ],
      "confidence_scores": [
        0.5978632509153741,
        0.5736085500966392,
        0.2964783697240253
      ],
      "avg_confidence": 0.48931672357867956,
      "min_confidence": 0.2964783697240253,
      "confidence_std": 0.13671636250764138,
      "low_confidence": true,
      "detailed_confidence": {
        "CMB": {
          "tag_name": "組み合わせ",
          "composite_confidence": 0.5978632509153741,
          "components": {
            "self_confidence": 0.8,
            "verifier_score": 0.2,
            "embedding_similarity": 0.7262108363845798
          },
          "reasoning": "問題は真偽値の組み合わせ数を数える計算（f を漸化式で求める）、いわゆる組み合わせ的なカウント処理だから。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "JDG": {
          "tag_name": "条件判定",
          "composite_confidence": 0.5736085500966392,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7120285003221308
          },
          "reasoning": "各ステップで AND／OR の場合分け（条件判定）を行い、それに応じた値を更新しているため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BRT": {
          "tag_name": "全探索",
          "composite_confidence": 0.2964783697240253,
          "components": {
            "self_confidence": 0.2,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7215945657467511
          },
          "reasoning": "全探索タグだが、実際は O(N) 漸化式で解くため、暴力解法には該当しない。ただし真偽値全体を考慮するという点で低い確信度で候補に含めた。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 671,
      "inferred_at": "2025-08-16T15:27:06.431636",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc189_e": {
      "contest_id": "abc189",
      "problem_index": "E",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc189/tasks/abc189_e",
      "editorial_url": "https://atcoder.jp/contests/abc189/editorial/539",
      "editorial_id": 539,
      "tags": [
        "座標回転",
        "格子点",
        "半分全列挙"
      ],
      "tag_ids": [
        "ROT",
        "LAT",
        "MIT"
      ],
      "confidence_scores": [
        0.8932702393046257,
        0.6731837979189303,
        0.23929380708596432
      ],
      "avg_confidence": 0.6019159481031734,
      "min_confidence": 0.23929380708596432,
      "confidence_std": 0.2716991268387188,
      "low_confidence": true,
      "detailed_confidence": {
        "ROT": {
          "tag_name": "座標回転",
          "composite_confidence": 0.8932702393046257,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.710900797682086
          },
          "reasoning": "問題の中心は座標回転（90度回転、鏡映）を含むアフィン変換の累積であり、いわゆる“座標回転”に該当します。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "LAT": {
          "tag_name": "格子点",
          "composite_confidence": 0.6731837979189303,
          "components": {
            "self_confidence": 0.4,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7106126597297676
          },
          "reasoning": "扱う点は整数格子点で、格子点の変換を扱うため“格子点”の要素を含みます。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "MIT": {
          "tag_name": "半分全列挙",
          "composite_confidence": 0.23929380708596432,
          "components": {
            "self_confidence": 0.05,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7309793569532144
          },
          "reasoning": "特に半分全列挙を用いるわけではないため、誤って含めています（低確信度）。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 757,
      "inferred_at": "2025-08-16T15:27:16.279602",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc189_f": {
      "contest_id": "abc189",
      "problem_index": "F",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc189/tasks/abc189_f",
      "editorial_url": "https://atcoder.jp/contests/abc189/editorial/541",
      "editorial_id": 541,
      "tags": [
        "確率/期待値DP",
        "DP",
        "全探索"
      ],
      "tag_ids": [
        "EDP",
        "DP",
        "BRT"
      ],
      "confidence_scores": [
        0.9100025391302133,
        0.8829820981956477,
        0.2603435010394183
      ],
      "avg_confidence": 0.6844427127884264,
      "min_confidence": 0.2603435010394183,
      "confidence_std": 0.3000862455047128,
      "low_confidence": true,
      "detailed_confidence": {
        "EDP": {
          "tag_name": "確率/期待値DP",
          "composite_confidence": 0.9100025391302133,
          "components": {
            "self_confidence": 0.98,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7266751304340449
          },
          "reasoning": "The problem focuses on computing the expected number of moves to reach the end using probabilities—this is a classic expected‐value DP scenario.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.8829820981956477,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7432736606521588
          },
          "reasoning": "We define f(i) in terms of f(i+1) … f(i+M) and use prefix sums to compute it in O(N), which is dynamic programming over positions.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BRT": {
          "tag_name": "全探索",
          "composite_confidence": 0.2603435010394183,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7344783367980608
          },
          "reasoning": "A naive simulation or brute‐force Monte Carlo could approximate the expectation, but it is not the intended efficient approach (low confidence).",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 2028,
      "inferred_at": "2025-08-16T15:27:20.373067",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc190_c": {
      "contest_id": "abc190",
      "problem_index": "C",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc190/tasks/abc190_c",
      "editorial_url": "https://atcoder.jp/contests/abc190/editorial/626",
      "editorial_id": 626,
      "tags": [
        "全探索",
        "組み合わせ",
        "二部マッチング"
      ],
      "tag_ids": [
        "BRT",
        "CMB",
        "BPM"
      ],
      "confidence_scores": [
        0.8950615077782478,
        0.5614721393023236,
        0.251500252416602
      ],
      "avg_confidence": 0.5693446331657245,
      "min_confidence": 0.251500252416602,
      "confidence_std": 0.26279174831082036,
      "low_confidence": true,
      "detailed_confidence": {
        "BRT": {
          "tag_name": "全探索",
          "composite_confidence": 0.8950615077782478,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7168716925941593
          },
          "reasoning": "Kが小さいことを利用して2^K通りの全探索(Brute Force)で解を求めています。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CMB": {
          "tag_name": "組み合わせ",
          "composite_confidence": 0.5614721393023236,
          "components": {
            "self_confidence": 0.85,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7382404643410789
          },
          "reasoning": "本問題ではK人それぞれの皿の選び方(2^K通り)を全探索し、組み合わせ(Combination)を列挙しています。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BPM": {
          "tag_name": "二部マッチング",
          "composite_confidence": 0.251500252416602,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7050008413886735
          },
          "reasoning": "直接的には用いませんが、皿と条件を二部グラフのマッチング問題として捉える解法案も考えうるため、可能性としてわずかに検討しました。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1378,
      "inferred_at": "2025-08-16T15:27:33.971580",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc190_d": {
      "contest_id": "abc190",
      "problem_index": "D",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc190/tasks/abc190_d",
      "editorial_url": "https://atcoder.jp/contests/abc190/editorial/628",
      "editorial_id": 628,
      "tags": [
        "約数列挙",
        "整数",
        "素因数分解"
      ],
      "tag_ids": [
        "DIV",
        "INT",
        "PFT"
      ],
      "confidence_scores": [
        0.9054303158908593,
        0.6770232105793741,
        0.44795926427886024
      ],
      "avg_confidence": 0.6768042635830313,
      "min_confidence": 0.44795926427886024,
      "confidence_std": 0.18676183892699189,
      "low_confidence": false,
      "detailed_confidence": {
        "DIV": {
          "tag_name": "約数列挙",
          "composite_confidence": 0.9054303158908593,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7514343863028646
          },
          "reasoning": "The solution explicitly enumerates all positive divisors x,y of 2N in O(√N) to count valid pairs, which is a classic divisor enumeration approach.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "INT": {
          "tag_name": "整数",
          "composite_confidence": 0.6770232105793741,
          "components": {
            "self_confidence": 0.4,
            "verifier_score": 1.0,
            "embedding_similarity": 0.723410701931247
          },
          "reasoning": "The problem is fundamentally about finding integer solutions (A,B) satisfying a Diophantine equation, focusing on integer arithmetic and parity conditions.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "PFT": {
          "tag_name": "素因数分解",
          "composite_confidence": 0.44795926427886024,
          "components": {
            "self_confidence": 0.55,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7598642142628674
          },
          "reasoning": "While the editorial uses direct divisor enumeration by trial up to √(2N), in practice one may factor N (or 2N) into primes to generate divisors efficiently. The approach is closely related to prime factorization-based divisor generation.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1520,
      "inferred_at": "2025-08-16T15:27:33.891805",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc190_e": {
      "contest_id": "abc190",
      "problem_index": "E",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc190/tasks/abc190_e",
      "editorial_url": "https://atcoder.jp/contests/abc190/editorial/630",
      "editorial_id": 630,
      "tags": [
        "DP",
        "ダイクストラ",
        "0-1 BFS"
      ],
      "tag_ids": [
        "DP",
        "DJK",
        "01B"
      ],
      "confidence_scores": [
        0.9173476981717984,
        0.48678892214192526,
        0.30264441544394083
      ],
      "avg_confidence": 0.5689270119192215,
      "min_confidence": 0.30264441544394083,
      "confidence_std": 0.2575849772965529,
      "low_confidence": true,
      "detailed_confidence": {
        "DP": {
          "tag_name": "DP",
          "composite_confidence": 0.9173476981717984,
          "components": {
            "self_confidence": 0.99,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7378256605726616
          },
          "reasoning": "本問題の主体はK≤17の頂点集合上での最短ハミルトン路をbit DPで解く典型的な部分集合DP（bitmask DP）だから。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "DJK": {
          "tag_name": "ダイクストラ",
          "composite_confidence": 0.48678892214192526,
          "components": {
            "self_confidence": 0.65,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7559630738064175
          },
          "reasoning": "特殊頂点間の距離を全頂点からの最短経路として前計算しており、これは単一始点最短経路問題（普通はDijkstra）に相当するため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "01B": {
          "tag_name": "0-1 BFS",
          "composite_confidence": 0.30264441544394083,
          "components": {
            "self_confidence": 0.2,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7421480514798028
          },
          "reasoning": "実装上は無向非加重グラフなのでBFSを使うが，BFSは0-1 BFSの特殊ケースと言えるため（ただし重みは全て1で，厳密には0-1 BFSは不要）。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 1080,
      "inferred_at": "2025-08-16T15:27:57.372755",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc190_f": {
      "contest_id": "abc190",
      "problem_index": "F",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc190/tasks/abc190_f",
      "editorial_url": "https://atcoder.jp/contests/abc190/editorial/631",
      "editorial_id": 631,
      "tags": [
        "Fenwick Tree(BIT)",
        "ビット演算",
        "組み合わせ"
      ],
      "tag_ids": [
        "BIT",
        "BOP",
        "CMB"
      ],
      "confidence_scores": [
        0.922196899606285,
        0.2975326127936639,
        0.25163287566746684
      ],
      "avg_confidence": 0.4904541293558053,
      "min_confidence": 0.25163287566746684,
      "confidence_std": 0.3058627810143327,
      "low_confidence": true,
      "detailed_confidence": {
        "BIT": {
          "tag_name": "Fenwick Tree(BIT)",
          "composite_confidence": 0.922196899606285,
          "components": {
            "self_confidence": 1.0,
            "verifier_score": 1.0,
            "embedding_similarity": 0.7406563320209504
          },
          "reasoning": "The solution uses a Fenwick Tree (BIT) to compute the initial inversion count in O(N log N), which is the core technique mentioned in the editorial.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "BOP": {
          "tag_name": "ビット演算",
          "composite_confidence": 0.2975326127936639,
          "components": {
            "self_confidence": 0.2,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7251087093122129
          },
          "reasoning": "Though the problem does not primarily hinge on bitwise operations, the Fenwick Tree implementation relies on low-level bit manipulations (i & -i) for updates and queries, so there is a minor connection.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "CMB": {
          "tag_name": "組み合わせ",
          "composite_confidence": 0.25163287566746684,
          "components": {
            "self_confidence": 0.1,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7054429188915561
          },
          "reasoning": "Inversion counting involves counting pairs (i,j) with A[i]>A[j], which is a form of combinatorial pair counting, but explicit combinatorial formulas are not used here, so this tag is only weakly related.",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 879,
      "inferred_at": "2025-08-16T15:28:03.926419",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    },
    "abc191_c": {
      "contest_id": "abc191",
      "problem_index": "C",
      "title": "",
      "problem_url": "https://atcoder.jp/contests/abc191/tasks/abc191_c",
      "editorial_url": "https://atcoder.jp/contests/abc191/editorial/612",
      "editorial_id": 612,
      "tags": [
        "グリッド",
        "格子点",
        "幾何"
      ],
      "tag_ids": [
        "GRID",
        "LAT",
        "GEO"
      ],
      "confidence_scores": [
        0.890076937991785,
        0.5876810701949126,
        0.49345088807305815
      ],
      "avg_confidence": 0.6570696320865852,
      "min_confidence": 0.49345088807305815,
      "confidence_std": 0.1691924648826083,
      "low_confidence": false,
      "detailed_confidence": {
        "GRID": {
          "tag_name": "グリッド",
          "composite_confidence": 0.890076937991785,
          "components": {
            "self_confidence": 0.95,
            "verifier_score": 1.0,
            "embedding_similarity": 0.700256459972617
          },
          "reasoning": "2次元の文字盤(grid)上でセルの周囲4マスを調べ、全体を走査するアルゴリズムを実装する典型的なグリッド処理問題のため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "LAT": {
          "tag_name": "格子点",
          "composite_confidence": 0.5876810701949126,
          "components": {
            "self_confidence": 0.9,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7589369006497083
          },
          "reasoning": "問題では格子点(lattice points)に対応する頂点を判定しており、周囲の4マスの'#'の数から頂点を見つける操作のため格子点が本質的に扱われているため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        },
        "GEO": {
          "tag_name": "幾何",
          "composite_confidence": 0.49345088807305815,
          "components": {
            "self_confidence": 0.7,
            "verifier_score": 0.0,
            "embedding_similarity": 0.7115029602435272
          },
          "reasoning": "多角形の自己交叉判定や頂点判定といった幾何的性質の解析を行う問題であるため。",
          "weights_used": {
            "self_conf": 0.4,
            "verifier": 0.3,
            "embed_sim": 0.3
          }
        }
      },
      "candidate_tags_count": 8,
      "editorial_text_length": 675,
      "inferred_at": "2025-08-16T15:28:01.255354",
      "model": "o4-mini",
      "method": "enhanced_composite_confidence"
    }
  },
  "metadata": {
    "processing_completed": true,
    "total_processed_in_session": 50,
    "successful_in_session": 49,
    "failed_in_session": 1,
    "processing_stats": {
      "contest_types": [
        "abc"
      ],
      "limit_applied": 50,
      "skip_existing": true,
      "min_difficulty": 200
    },
    "last_updated": "2025-08-16T15:39:09.371033",
    "inference_model": "o4-mini",
    "inference_method": "enhanced_composite_confidence",
    "total_problems": 59,
    "format_simplified_at": "2025-08-16T15:39:09.371033",
    "simplified_reason": "Removed verbose reasoning and detailed confidence to reduce token usage"
  }
}