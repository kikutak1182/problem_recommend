{"custom_id": "tag_inference_abc246_e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-02 21:00:00+0900 - 2022-04-02 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official E - Bishop 2 Editorial by physics0523 前知識: 01-bfs 以下の問題を解くことを考えてみましょう。 全ての辺の長さが \\(0\\) か \\(1\\) である ような(有向)グラフが与えられます。 このグラフの頂点 \\(S\\) から各頂点までの最短距離を求めてください。 ABCのE問題に挑む方であれば、この問題が dijkstra 法などの最短経路問題を解くアルゴリズムによって解けることはご存じかと思います。今回は、それよりも効率的な解法を紹介します。 早速、 01-bfs とは何かを具体的に見ていきましょう。 まず、空の deque を用意する。 暫定的な最短距離 \\(D[\\) 頂点番号 \\(]=\\{\\) 暫定距離 \\(\\}\\) を以下のように定義する。 \\(D[S]=0\\) \\(S\\) 以外の頂点 \\(x\\) について、 \\(D[x]=\\infty\\) deque の唯一の要素として、頂点 \\(S\\) を入れる。 deque が空になるまで、以下を繰り返す。 deque の先頭から要素をひとつ取り出し、これを頂点 \\(V\\) とする。 \\(V\\) が未探索であれば、以下の操作を行った上で \\(V\\) を探索済みとする。 \\(V\\) に隣接する全ての頂点 \\(W\\) について、以下を行う。 もし \\(V\\) と \\(W\\) を結ぶ辺の長さが \\(0\\) であり、 \\(D[W]>D[V]\\) であれば、 deque の先頭に \\(W\\) を入れて、 \\(D[W]=D[V]\\) とする。 もし \\(V\\) と \\(W\\) を結ぶ辺の長さが \\(1\\) であり、 \\(D[W]>D[V]+1\\) であれば、 deque の末尾に \\(W\\) を入れて \\(D[W]=D[V]+1\\) とする。 大まかな流れは dijkstra 法と同\n\n[Candidate Tags]\nDJK: ダイクストラ\\nBFS: BFS\\n01B: 0-1 BFS\\nCOW: 牛ゲー\\nDFS: DFS\\nDP: DP\\nKDP: 桁DP\\nMOS: Mo's algorithm\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["DJK", "BFS", "01B", "COW", "DFS", "DP", "KDP", "MOS"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc246_f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-02 21:00:00+0900 - 2022-04-02 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official F - typewriter Editorial by physics0523 この問題は、 包除原理 を使って解くことができます。 例えば、 \\(N=3\\) の場合なら、 \\((\\) \\(1\\) 段目、 \\(2\\) 段目、 \\(3\\) 段目の少なくとも \\(1\\) 段以上で入力できる文字列の総数 \\() = \\) \\(+\\) \\(1\\) 段目で入力できる文字列 \\(+\\) \\(2\\) 段目で入力できる文字列 \\(+\\) \\(3\\) 段目で入力できる文字列 \\(-\\) \\(1\\) 段目、 \\(2\\) 段目双方で入力できる文字列 \\(-\\) \\(1\\) 段目、 \\(3\\) 段目双方で入力できる文字列 \\(-\\) \\(2\\) 段目、 \\(3\\) 段目双方で入力できる文字列 \\(+\\) \\(1\\) 段目、 \\(2\\) 段目、 \\(3\\) 段目のすべてで入力できる文字列 となります。( \\(N\\) が小さい場合、ベン図のイメージを持つのも理解の助けになるでしょう。) \\(N \\le 18\\) と小さいので、着目する段の集合 \\(2^N-1\\) 通りを全探索することを考えます。このとき、以下の問題が解ければ元の問題も解けることになります。 \\(A_1\\) 段目、 \\(A_2\\) 段目、 \\(\\dots A_k\\) 段目のすべてで入力できる文字列は何通りか？ (なお、 \\(A\\) に含まれない段についてはその段で入力できてもできなくてもよい。) 文字列 \\(S\\) が条件を満たす必要十分条件を求めます。 明らかに、 \\(S\\) に含まれる全ての文字は、 \\(A\\) に含まれる全ての段で入力可能であるべきです。逆に、 \\(S\\) が \\(A\\) に含まれる全ての段で入力可能な文字しか含まないならば \\(S\\) は条件を満たします。 よって、この問題の答えは ( \\(A\\) に\n\n[Candidate Tags]\nBOP: ビット演算\\nPFT: 素因数分解\\nLCP: LCP\\nLCM: 最小公倍数\\nDIV: 約数列挙\\nCMB: 組み合わせ\\nMIT: 半分全列挙\\nBRT: 全探索\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["BOP", "PFT", "LCP", "LCM", "DIV", "CMB", "MIT", "BRT"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc246_g", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-02 21:00:00+0900 - 2022-04-02 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official G - Game on Tree 3 Editorial by leaf1415 「両者が最適に行動したときの高橋君の得点が \\(X\\) 以上か？」という判定問題を解くことができれば、それが真となる最大の \\(X\\) を二分探索で求めることで本問題の答えが得られます。 よって、以下ではこの判定問題を解く方法を述べます。 \\(X \\leq 0\\) の場合は自明なため、 \\(X > 0\\) を仮定します。 この判定問題を解くにあたっては、各頂点に書かれた整数が \\(X\\) 以上かどうかのみに注目すれば良いです。 そこで、 \\(A_i \\geq X\\) を満たす頂点 \\(i\\) を黒に、 \\(A_i < X\\) を満たす頂点 \\(i\\) を白に塗ります。 そして、下記の 白黒ゲーム を考えます。 ゲームが終了するまで下記の手順 1. から手順 4. を繰り返す。 現在コマがある頂点が黒のとき、高橋君の勝ちでゲームが終了する。 現在コマがある頂点が葉ならば、青木君の勝ちでゲームが終了する。 青木君が根以外の頂点を任意に \\(1\\) 個選び、その頂点を白で塗る。 高橋君がコマを、いまコマがある頂点の子のどれかに移動する。 このとき、「判定問題の答えが真」であるのは、次が成り立つことと同値です。 頂点 \\(1\\) にコマが置かれた状態から白黒ゲームをはじめ、両者が最適に行動したときに高橋君が勝つ（すなわち、高橋君が必勝である）。 上の条件が成り立つかを動的計画法（いわゆる木 DP ）で求めます。 \\(v = 1, 2, \\ldots, N\\) に対して、 \\(\\mathrm{dp}[v]\\) を次の通りに定義します。 頂点 \\(v\\) にコマが置かれた状態から白黒ゲームを始める。ただし、ゲームを始める前に、青木君は好きな個数（ \\(0\\) 個でも良い）の頂点を選んでそれらを\n\n[Candidate Tags]\nBPM: 二部マッチング\\nGAM: ゲーム\\nRRT: 全方位木DP\\nCOW: 牛ゲー\\nMGCD: 最大公約数\\nBRT: 全探索\\nSCH: 区間スケジューリング\\nGRD: 貪欲法\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["BPM", "GAM", "RRT", "COW", "MGCD", "BRT", "SCH", "GRD"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc246_ex", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-02 21:00:00+0900 - 2022-04-02 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official Ex - 01? Queries Editorial by leaf1415 「 \\(S\\) に含まれるすべての ? をそれぞれ独立に 0 または 1 に置き換えて得られる文字列の部分列としてあり得る文字列」を、単に「 \\(S\\) から作れる文字列」と呼びます。ここでは便宜上、空文字列も \\(S\\) から作れることにします。 文字列 \\(S = s_1s_2\\ldots s_N\\) に対し、 \\(i = 0, 1, \\ldots, N\\) について \\(\\mathrm{dp}[i][0] := \\) （ \\(S\\) の先頭 \\(i\\) 文字 \\(s_1s_2\\ldots s_i\\) から作れる文字列のうち末尾が 0 のものの個数） \\(\\mathrm{dp}[i][1] := \\) （ \\(S\\) の先頭 \\(i\\) 文字 \\(s_1s_2\\ldots s_i\\) から作れる文字列のうち末尾が 1 のものの個数） とおきます。 このとき、各クエリで出力すべき値は、各時点の \\(S\\) に対する \\(\\mathrm{dp}[N][0] + \\mathrm{dp}[N][1]\\) です。 よって、これを計算することを考えます。 ます明らかに、 \\(\\mathrm{dp}[0][0] = \\mathrm{dp}[0][1] = 0\\) です。以下で、 \\(i = 1, 2, \\ldots, N\\) について、「 \\(\\mathrm{dp}[i-1][0]\\) と \\(\\mathrm{dp}[i-1][1]\\) の値が分かっているときに、 \\(\\mathrm{dp}[i][0]\\) と \\(\\mathrm{dp}[i][1]\\) を求める方法」を考えます。 \\(s_i = \\) 0 の場合を考えます。 \\(s_1s_2\\ldots s_{i-1}\\) から作れる文字列は\n\n[Candidate Tags]\nMOS: Mo's algorithm\\nMIT: 半分全列挙\\nDP: DP\\nKDP: 桁DP\\nSQD: 平方分割\\nEDT: 編集距離\\nDIV: 約数列挙\\nRRT: 全方位木DP\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["MOS", "MIT", "DP", "KDP", "SQD", "EDT", "DIV", "RRT"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc247_d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-10 21:00:00+0900 - 2022-04-10 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official D - Cylinder Editorial by kyopro_friends 筒の中のボールの状態をランレングス符号化を行って保持します。 つまり、例えば 1 2 3 1 3 4 1 10 10 というクエリの後の筒の状態を、「 \\(2\\) が \\(3\\) 個、 \\(3\\) が \\(4\\) 個、 \\(10\\) が \\(10\\) 個」という形で保持します。クエリ \\(1\\) 回につき、このリストの長さは高々 \\(1\\) しか増えないため、クエリ処理全体を通して長さが \\(Q\\) を超えることはありません。 この形式の情報を deque で持つことにすれば、挿入クエリは \\(O(1)\\) 、取り出しクエリは \\(O(1+(\\text{dequeから削除した要素の個数}))\\) となります。したがって、全体の計算量は \\(O(Q)\\) で問題を解くことができました。 なお、この問題では、厳密にランレングス符号化を行わなくとも AC を得ることができます。例えば 1 10 3 1 10 10 というクエリの後の筒の状態をランレングス符号化すると「 \\(10\\) が \\(13\\) 個」となりますが、単に「 \\(10\\) が \\(10\\) 個、 \\(10\\) が \\(3\\) 個」としても全体の計算量は \\(O(Q)\\) となります。 posted: last update:\n\n[Candidate Tags]\nDIV: 約数列挙\\nMIT: 半分全列挙\\nMAT: 行列\\nMOS: Mo's algorithm\\nCMB: 組み合わせ\\nSCH: 区間スケジューリング\\nEDT: 編集距離\\nPOL: 多項式\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["DIV", "MIT", "MAT", "MOS", "CMB", "SCH", "EDT", "POL"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc247_e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-10 21:00:00+0900 - 2022-04-10 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official E - Max Min Editorial by Nyaan まず、愚直に \\(L,R\\) を全探索すれば \\(\\mathrm{O}(N^3)\\) あるいは \\(\\mathrm{O}(N^2)\\) でこの問題を解くことができますが、 \\(N \\leq 2\\times 10^5\\) なので TLE してしまいます。そこで、アルゴリズムを上手く用いて \\(\\mathrm{O}(N)\\) でこの問題を解く方法を紹介します。 まず、この問題は条件を満たす整数の組 \\((L,R)\\) の数え上げですが、少し見方を変えると次のように言い換えられます。 \\(A\\) の連続部分列 \\(A_{L}, A_{L+1}, \\dots, A_{R}\\) のうち、最大値が \\(X\\) , 最小値が \\(Y\\) となるものは何個あるか。 このように \\((L,R)\\) の数え上げを区間の数え上げとみなすと見通しが良くなります。 ただ、これでもまだ以下に述べる通り厄介な要素が残っているので、条件を満たす連続部分列がどのようなものかを考察して問題を単純化できないか考えてみましょう。 \\[A = (4,2,5,4,3,4,2), X=4, Y=2\\] の場合を考えましょう。 この例では \\(A_3 = 5\\) が厄介です。 \\(A_3 = 5\\) は \\(X = 4\\) よりも大きいので、 \\(A_3\\) を含む連続部分列はすべて条件を満たしません。このような数を残したまま考察を進めると少し面倒な場合分けが必要になります。 少し考察を進めると、よくよく考えると \\(A_3\\) を含む連続部分列が条件を満たさないということは、列から \\(A_3\\) を取り除いて前後で分割して、それぞれの列に対して条件を満たす列を数え上げてもよい、ということになります。すなわち、 \\(A\\) の前 \\(2\\) つを\n\n[Candidate Tags]\nMOS: Mo's algorithm\\nMIT: 半分全列挙\\nDIV: 約数列挙\\nCUM: 累積和\\nSCH: 区間スケジューリング\\nSQD: 平方分割\\nPIE: 包除原理\\nCOW: 牛ゲー\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["MOS", "MIT", "DIV", "CUM", "SCH", "SQD", "PIE", "COW"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc247_f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-10 21:00:00+0900 - 2022-04-10 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official F - Cards Editorial by kyopro_friends \\(1,\\ldots,N\\) を頂点とし、 \\((P_i,Q_i)\\) に辺を張ったグラフ \\(G\\) を考えます。問題は「辺の部分集合 \\(E\\) であって、辺被覆となるものは何通りありますか？」と読み替えることができます。この問題は明らかに連結成分ごとに考えることができます。 \\(P,Q\\) はともに \\((1,\\ldots,N)\\) の並び替えなので、 \\(G\\) はどの頂点の次数も \\(2\\) であり、サイクルの集まりになることがわかります。したがって、サイクルの場合の問題が解ければ良いです。 あとで使うので、まずは次の問題を考えます。 「 \\(1,2,\\ldots,M\\) の中からいくつかの数を選びます。ただし、連続する \\(2\\) 数のどちらは必ず選ぶ必要があります。選び方は何通りありますか？」 この問題の答えを \\(f(M)\\) とすると、 \\(f(1)=2,f(2)=3,f(M)=f(M-1)+f(M-2)\\) を満たすことがわかります。（ \\(M\\) を選ぶか選ばないかで残りの選び方がどうなるか考えるとわかります） 本題に戻ります。 \\(1,\\ldots,M\\) を頂点とする \\(M\\) 頂点のサイクルの辺の部分集合であって、辺被覆となるものは何通りあるでしょうか。これは「隣り合う辺のどちらかは必ず選ぶ必要があります。選び方は何通りありますか？」という先ほどとよく似た問題になります。この問題の答えを \\(g(M)\\) とします。辺 \\((1,M)\\) を選ぶか選ばないか場合分けすることで、答えは \\(g(1)=1,g(2)=3,g(3)=4,g(M)=f(M-1)+f(M-3)\\) を満たすことがわかります。 以上により、 \\(M\\leq N\\) の範囲の \\(f(M)\n\n[Candidate Tags]\nCOW: 牛ゲー\\nDIV: 約数列挙\\nBPM: 二部マッチング\\nSCH: 区間スケジューリング\\nMIT: 半分全列挙\\nMOS: Mo's algorithm\\nMAP: 写像12相\\nCMB: 組み合わせ\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["COW", "DIV", "BPM", "SCH", "MIT", "MOS", "MAP", "CMB"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc247_g", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-10 21:00:00+0900 - 2022-04-10 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official G - Dream Team Editorial by kyopro_friends 概略：大学・得意分野を頂点、人を辺としたグラフを考えると、元の問題は最大重みマッチングを求める問題になります。二部グラフの最大重みマッチングは最小費用流を用いて解けます。 次のようなグラフを構成します。 ソースを表す頂点 \\(S\\) 、シンクを表す頂点 \\(T\\) 、大学を表す頂点 \\(X_i\\) 、得意分野を表す頂点 \\(Y_i\\) を用意する 人 \\(i\\) を表す辺として、 \\(X_{A_i}\\) から \\(Y_{B_i}\\) へ容量 \\(1\\) コスト \\(C_i\\) の辺を張る 各 \\(i\\) について、 \\(S\\) から \\(X_i\\) 、 \\(Y_i\\) から \\(T\\) へ容量 \\(1\\) 、コスト \\(0\\) の辺を張る サンプル \\(1\\) に対するグラフは以下のようになります このとき、 \\(i\\) 人で構成されるドリームチームの強さの合計の最大値は、 \\(S\\) から \\(T\\) への流量 \\(i\\) のフローの 最大 費用となります。十分大きな定数 \\(\\rm BIG\\) を用いて辺のコストを次のように変更することで、 最小 費用流に変換できます 人 \\(i\\) を表す辺として、 \\(X_{A_i}\\) から \\(Y_{B_i}\\) 間に容量 \\(1\\) コスト \\({\\rm BIG}-C_i\\) の辺を張る \\(S\\) から \\(T\\) への流量の最大値は \\(M:=\\min(\\#\\{A_i\\},\\#\\{B_i\\})\\) なので、 \\(O(M(M+N)\\log(M+N))\\) でこの問題が解けました。 posted: last update:\n\n[Candidate Tags]\nBPM: 二部マッチング\\nMCF: 最小費用流\\nSCH: 区間スケジューリング\\nCOW: 牛ゲー\\nMXF: 最大流\\nOPT: 最適化\\nMGCD: 最大公約数\\nBRT: 全探索\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["BPM", "MCF", "SCH", "COW", "MXF", "OPT", "MGCD", "BRT"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc247_ex", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-10 21:00:00+0900 - 2022-04-10 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official Ex - Rearranging Problem Editorial by Nyaan まず、次の補題を示します。 \\((1,2\\dots,N)\\) を並べ替えた列 \\(p = (p_1,p_2,\\dots,p_N)\\) について次の事実が成り立つ。 \\(i,j (i \\neq j)\\) を選んで \\(p_i\\) と \\(p_j\\) を swap したとき、 \\(i \\to p_i\\) に辺が張られた \\(N\\) 頂点 \\(N\\) 辺のグラフに含まれるサイクル (大きさ \\(1\\) のサイクルも含む) の個数は \\(1\\) 増えるか \\(1\\) 減る。 (証明) サイクルに注目して考えると、あり得るのは次の \\(2\\) つのいずれかです。 長さ \\(2\\) 以上のサイクル \\(a_1 \\to a_2 \\to \\dots \\to a_n \\to a_1\\) から異なる 2 点 \\(a_i,a_j (i \\lt j)\\) を選んで \\(p_{a_i}\\) と \\(p_{a_j}\\) を swap する。 長さ \\(1\\) 以上のサイクル \\(a_1 \\to a_2 \\to \\dots \\to a_n \\to a_1,b_1 \\to b_2 \\to \\dots b_n \\to b_1\\) から \\(a_i,b_j\\) を選んで \\(p_{a_i}\\) と \\(p_{b_j}\\) を swap する。 前者の場合、サイクルは \\(a_1 \\to a_2 \\to \\dots \\to a_i \\to a_{j+1} \\to \\dots \\to a_n \\to a_1\\) と \\(a_{i+1} \\to a_{i+2} \\to \\dots \\to a_{j} \\to a_{i+1}\\) の 2 つに分かれるのでサイクルは 1 個増えます。 後者の場合、サイクルは \\(a_1 \n\n[Candidate Tags]\nKDP: 桁DP\\nDP: DP\\nDIV: 約数列挙\\nFFT: FFT/NTT\\nCOW: 牛ゲー\\nBDP: bitDP\\nCMB: 組み合わせ\\nADP: Alien DP\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["KDP", "DP", "DIV", "FFT", "COW", "BDP", "CMB", "ADP"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc248_c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-16 21:00:00+0900 - 2022-04-16 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official C - Dice Sum Editorial by nok0 数列を全通り試そうとすると、 \\(M^N\\) 種類の数列が考えられるため、実行時間制限には到底間に合いません。 数列を先頭から決めていくこととします。 ここで、以下の事実に着目します。 数列を先頭から決めていく際、覚えておくべき必要があるものはその時点での数列の総和のみであり、具体的に各要素の値が何であったかは捨象してよい。 このことを用いると、動的計画法で解くことができます。 DP の定義 \\(\\mathrm{dp}[i][j]:=\\) 数列の先頭から \\(i\\) 項まで決めた際に、総和が \\(j\\) であるような数列の決め方の総数 \\(i\\) としては \\(0\\) 以上 \\(N\\) 以下、 \\(j\\) としては \\(1\\) 以上 \\(K\\) 以下を考えれば良いので、状態数は \\(\\mathrm{Ο}(NK)\\) です。 DP の初期値 はじめ、 \\(\\mathrm{dp}[0][0] = 1\\) で、残りは \\(0\\) で埋めます。 DP の遷移 \\(i\\) の昇順に計算していきます。 \\(j = 0, \\ldots, K-1\\) 、 \\(k = 1,\\ldots,M\\) について もし \\(j + k \\leq K\\) ならば、 \\(\\mathrm{dp}[i+1][j + k]\\) に \\(\\mathrm{dp}[i][j]\\) を加算する。 と遷移すればよいです。 答え 最終的に、 \\(\\mathrm{dp}[N][1] + \\mathrm{dp}[N][2] + \\ldots + \\mathrm{dp}[N][K]\\) が答えとなります。 計算量は \\(\\mathrm{Ο}(NMK)\\) です。 実装例 (C++): #include <bits/stdc++.h> #include <a\n\n[Candidate Tags]\nFPS: FPS\\nDP: DP\\nKDP: 桁DP\\nDIV: 約数列挙\\nBDP: bitDP\\nMOS: Mo's algorithm\\nGND: Grundy数\\nPFT: 素因数分解\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["FPS", "DP", "KDP", "DIV", "BDP", "MOS", "GND", "PFT"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc248_d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-16 21:00:00+0900 - 2022-04-16 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official D - Range Count Query Editorial by nok0 \\(x = 1,\\ldots,N\\) それぞれについて、 \\(A_i = x\\) なる \\(i\\) を昇順に管理した配列を \\(\\mathrm{idx}_x\\) とします。 このとき、各クエリは以下のように言い換えられます。 \\(L,R,X\\) が与えられる。 \\(\\mathrm{idx}_X\\) の要素のうち、 \\(L\\) 以上 \\(R\\) 以下のものは何個あるか答えよ。 このクエリは \\(\\mathrm{idx}_X\\) の要素のうち \\(L\\) 以上の最小の要素は前から何番目か、 \\(R + 1\\) 以上の最小の要素は前から何番目かを求めることで解くことができ、これらは二分探索により \\(\\mathrm{Ο}(\\log N)\\) で求められます。 計算量は \\(\\mathrm{Ο}(N+Q\\log N)\\) です。 実装例 (C++): #include <bits/stdc++.h> using namespace std; int main() { int n; cin >> n; vector<vector<int>> idx(n + 1); for(int i = 0; i < n; i++) { int a; cin >> a; idx[a].push_back(i); } int q; cin >> q; while(q--) { int l, r, x; cin >> l >> r >> x; cout << lower_bound(idx[x].begin(), idx[x].end(), r) - lower_bound(idx[x].begin(), idx[x].end(), l - 1) << endl; } } posted: last update:\n\n[Candidate Tags]\nBIN: 二分探索\\nMOS: Mo's algorithm\\nCUM: 累積和\\nLIS: LIS\\nMIT: 半分全列挙\\nDIV: 約数列挙\\nBRT: 全探索\\nSCH: 区間スケジューリング\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["BIN", "MOS", "CUM", "LIS", "MIT", "DIV", "BRT", "SCH"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc248_e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-16 21:00:00+0900 - 2022-04-16 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official E - K-colinear Line Editorial by mechanicalpenciI \\(K=1\\) のときは、 \\(N\\) 点のうちある \\(1\\) 点を通る直線が条件をみたし、 \\(N\\geq 1\\) が保証されているので、そのようなものは無数に存在します。 具体的には \\(N\\) 点のうち \\(1\\) 点を取り出してその座標を \\((x_0,y_0)\\) とすると、任意の実数 \\(a\\) に対して、 \\(y-y_0=a(x-x_0)\\) で表される直線がすべて条件をみたします。 一方、特定の相異なる \\(2\\) 点を通る直線はただ \\(1\\) つに定まる事から、 \\(N\\) 点のうち \\(2\\) 点以上を通る直線は高々 \\(\\frac{N(N-1)}{2}\\) 本しか存在しません。それぞれに対して \\(N\\) 点のうち何点を通るか調べればよいです。 ここで、相異なる \\(2\\) 点 \\(A\\) \\((x_0,y_0)\\) と \\(B\\) \\((x_1,y_1)\\) を通る直線の上に \\(P\\) \\((x,y)\\) が乗っている事は ある実数 \\(k\\) を用いて \\(\\overrightarrow{AP}=k\\overrightarrow{AB}\\) と書ける事と同値であり、これは \\((x_1-x_0)(y-y_0)\\) と \\((y_1-y_0)(x-x_0)\\) が等しいかどうかで判定することができます。 よって、判定は \\(O(1)\\) で出来るため、それぞれの直線に対して何点が乗っているかは \\(O(N)\\) で判定できます。直線の数が \\(O(N^2)\\) であることから、全体で \\(O(N^3)\\) で求まり、十分高速にこの問題を解くことができました。同じ直線を重複して数えないように注意してください。 c++による実装例 : #\n\n[Candidate Tags]\nLAT: 格子点\\nCOW: 牛ゲー\\nDIV: 約数列挙\\nSCH: 区間スケジューリング\\nMOS: Mo's algorithm\\nCVX: 凸包\\nDLG: 離散対数\\nLCP: LCP\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["LAT", "COW", "DIV", "SCH", "MOS", "CVX", "DLG", "LCP"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc248_f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-16 21:00:00+0900 - 2022-04-16 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official F - Keep Connect Editorial by mechanicalpenciI 答えを動的計画法で求めることを考えます。 辺について、 \\(1\\leq i\\leq N-1\\) について、頂点 \\(i\\) と頂点 \\(i+1\\) を結んでいる辺を辺 \\(a_i\\) , \\(1\\leq i\\leq N-1\\) について、頂点 \\(N+i\\) と頂点 \\(N+i+1\\) を結んでいる辺を辺 \\(b_i\\) \\(0\\leq i\\leq N-1\\) について、頂点 \\(i+1\\) と頂点 \\(N+i+1\\) を結んでいる辺を辺 \\(c_i\\) とおきます。 ここで、各 \\(k=0,1,\\ldots,N-1\\) について、 \\(i\\leq k\\) なる辺 \\(a_i\\) , \\(b_i\\) , \\(c_i\\) を取り除くか決めた時の頂点 \\(1,2,\\ldots,k+1\\) と \\(N+1,N+2,\\ldots,N+k+1\\) の \\((2k+2)\\) 頂点からなる部分グラフ \\(G_k\\) について考えます。ここで、 \\(G=G_{N-1}\\) です。 ここで、もし \\(G_k\\) に頂点 \\(k+1\\) も \\(N+k+1\\) も含まない（空でない）連結成分が存在したとすると、もしこの後 \\(i> k\\) なる辺 \\(a_i\\) , \\(b_i\\) , \\(c_i\\) をすべて残しても最終的にグラフが全体で連結となることはありません。よって、最終的に \\(G\\) が連結になるような 部分グラフ \\(G_k\\) の状態としてあり得るものは 状態 \\(0\\) : \\(G_k\\) は連結 状態 \\(1\\) : \\(G_k\\) は \\(2\\) つの連結成分に分かれており、一方には頂点 \\(k+1\\) 、もう一方には頂点 \\(N+k+1\\) が属している。 の \\(\n\n[Candidate Tags]\nKDP: 桁DP\\nDP: DP\\nRRT: 全方位木DP\\nBDP: bitDP\\nSCC: SCC\\nCOW: 牛ゲー\\nLAT: 格子点\\nBPM: 二部マッチング\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["KDP", "DP", "RRT", "BDP", "SCC", "COW", "LAT", "BPM"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc248_g", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-16 21:00:00+0900 - 2022-04-16 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official G - GCD cost on the tree Editorial by mechanicalpenciI 根付き木として考え、木DPにより解くことを考えます。 また、以下では、木上の頂点 \\(u,v\\) について、 \\(f(u,v)\\) で \\(u=v\\) ならば \\(1\\) , \\(u\\neq v\\) ならば \\(u\\) と \\(v\\) の結ぶ単純パス上の端点を含む頂点数として定義します。 すなわち、 \\(2\\) 頂点間の距離 \\(d(u,v)\\) に対してつねに \\(f(u,v)=d(u,v)+1\\) です。 また、 \\(g(u,v)\\) を \\(u=v\\) ならば \\(A_u\\) , \\(u\\neq v\\) ならば \\(u\\) と \\(v\\) の結ぶ単純パス上おける \\(\\gcd(A_{p_1},\\ldots,A_{p_k})\\) の値として定義します。 ここで、相異なる \\(2\\) 頂点について、 \\(C(u,v)=f(u,v)g(u,v)\\) です。 最初、各頂点が独立している状態から、深さ優先探索の帰りがけ順にしたがって、根が \\(r\\) である木 \\(T\\) に根が \\(r'\\) である木 \\(T'\\) を「 \\(r\\) の直接の子に \\(r'\\) を追加する」という操作でマージするという操作を繰り返すことで元の木を作ることができます。この操作は元の木の辺数 \\(|T|-1\\) 回だけ行われます。 この過程で出来る各木 \\(T\\) について、その木に対する答え \\(ans(T)=\\displaystyle\\sum_{i=1}^{|T|-1}\\sum_{j=i+1}^{|T|}C(i,j)\\) を求め、更新していくことを考えます。 ここで、 \\(r\\) を根とする根付き木 \\(T\\) について、 \\(cnt(T,x)\\) で \\(T\\) の頂点 \n\n[Candidate Tags]\nGCD: GCD\\nRRT: 全方位木DP\\nHLD: HLD\\nDP: DP\\nCOW: 牛ゲー\\nPFT: 素因数分解\\nTRE: 木\\nLCM: 最小公倍数\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["GCD", "RRT", "HLD", "DP", "COW", "PFT", "TRE", "LCM"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc248_ex", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-16 21:00:00+0900 - 2022-04-16 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official Ex - Beautiful Subsequences Editorial by nok0 \\(K=0\\) の場合 \\(K=0\\) の場合、以下の手法でこの問題に答えることができます。 遅延セグ木の \\(L\\) 番目の要素で、 \\((\\mathrm{max}(P_L,\\ldots,P_R) - \\mathrm{min}(P_L,\\ldots,P_R)) - (R -L )\\) を管理します。 実はこの管理は区間加算のみを使って可能なので、区間加算 - 区間最小値とその個数の取得 を行う遅延セグ木を用い、 \\(R\\) を \\(1,\\ldots,N\\) と動かすことによりこの問題に答えることができます。 遅延セグ木の更新方法 \\(-(R-L)\\) の部分は容易なので、以下では \\(\\mathrm{max}(P_L,\\ldots,P_R)\\) の部分をどのように区間加算によって管理するかを述べます。 ここで、stack を用いて最大値を管理するテクニックを応用することを考えます。 Stack で最大値を管理するテクニック ある \\(R\\) を取ってきたとき、 \\(\\mathrm{max}(A_i, A_{i+1},\\ldots,A_R)\\) は \\(i\\) について単調非増加になっています。 \\(R\\) が \\(1,2,\\ldots,N\\) と順に増加していくとき、 \\(\\mathrm{max}(A_i, A_{i+1},\\ldots,A_R) \\neq \\mathrm{max}(A_{i+1}, A_{i+2},\\ldots,A_R)\\) なる \\(i\\) は、以下の手法を用いることにより stack で管理することができます。 空の stack を用意する。 R が 増加するたびに、以下を行う。 stack が空でなく、stack の 先頭の値が \\(A_R\\) \n\n[Candidate Tags]\nLSG: 遅延セグ木\\nSCH: 区間スケジューリング\\nMOS: Mo's algorithm\\nLIS: LIS\\nSEG: セグメント木\\nEDT: 編集距離\\nCMB: 組み合わせ\\nGRD: 貪欲法\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["LSG", "SCH", "MOS", "LIS", "SEG", "EDT", "CMB", "GRD"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc249_c", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-23 21:00:00+0900 - 2022-04-23 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official C - Just K Editorial by PCTprobability \\(N\\) 個の文字列のうち、いくつか選ぶ方法は \\(2^N\\) 通りあります。 この全てに対して、「選んだ文字列の中でちょうど \\(K\\) 個の文字列に登場する英小文字」の種類数を求めて最大値を出力すればよいです。 計算量は \\(\\mathrm{O}(2^N \\times N \\times σ)\\) となります。ただし、 \\(σ\\) は英小文字の種類数です。 実装の際には、それぞれの文字列を選ぶかどうかを \\(N\\) 桁の \\(2\\) 進数とみなし、 \\(0\\) 以上 \\(2^N-1\\) 以下の整数と対応させる bit 全探索と呼ばれている手法が便利です。 実装例 #include <bits/stdc++.h> using namespace std; int main() { int n,k; cin>>n>>k; vector<string> s(n); for(int i=0;i<n;i++) cin>>s[i]; int ans=0; for(int i=0;i<(1<<n);i++){ vector<int> sum(26); for(int j=0;j<n;j++){ if((i>>j)&1){ for(int x=0;x<s[j].size();x++) sum[s[j][x]-'a']++; } } int now=0; for(int j=0;j<26;j++) if(sum[j]==k) now++; ans=max(ans,now); } cout<<ans<<endl; } posted: last update:\n\n[Candidate Tags]\nEDT: 編集距離\\nLCP: LCP\\nBRT: 全探索\\nZ: Z-algorithm\\nCMB: 組み合わせ\\nSA: suffix array\\nDIV: 約数列挙\\nPAL: 回文判定\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["EDT", "LCP", "BRT", "Z", "CMB", "SA", "DIV", "PAL"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc249_d", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-23 21:00:00+0900 - 2022-04-23 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official D - Index Trio Editorial by KoD \\(A\\) において整数 \\(x\\) が登場する回数を \\(c(x)\\) と表すことにします。 条件を満たす組のうち、 \\(A_i = p, A_j = q, A_k = r\\) を満たすものの個数は \\(c(p)c(q)c(r)\\) です。また \\(\\frac{A_i}{A_j} = A_k \\Leftrightarrow p = qr\\) です。 \\(M = \\max_i A_i\\) とおきます。明らかに \\(x > M\\) のとき \\(c(x) = 0\\) であり、また \\(A\\) の要素は全て整数であるので、上記の \\(p, q, r\\) として考えるべき組は、以下の条件を全て満たすものに絞ることができます。 \\(1 \\leq p, q, r \\leq M\\) \\(p = qr\\) \\(p, q, r\\) は整数 これを満たす \\((p, q, r)\\) の組を列挙することができれば、それら全てに対して \\(c(p)c(q)c(r)\\) を計算して足し合わせたものを答えればよいということになります。 さて、実は前述の条件を満たす \\((p, q, r)\\) の組はそれほど多くないことが示せます。 \\(qr = p \\leq M\\) より、 \\(q\\) を \\(1 \\leq q \\leq M\\) の範囲で固定したときに \\(r\\) として考えるべき値は \\(1, \\dots, \\left\\lfloor \\frac{M}{q} \\right\\rfloor\\) のみです。 \\(p\\) は \\(q, r\\) の値によって決定されるので、条件を満たす \\((p, q, r)\\) の個数は \\[\\begin{aligned} \\left\\lfloor \\frac{M}{1} \\right\\rfloor \n\n[Candidate Tags]\nLCM: 最小公倍数\\nDIV: 約数列挙\\nMGCD: 最大公約数\\nCMB: 組み合わせ\\nGCD: GCD\\nMOS: Mo's algorithm\\nEUC: ユークリッドの互除法\\nMAP: 写像12相\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["LCM", "DIV", "MGCD", "CMB", "GCD", "MOS", "EUC", "MAP"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc249_e", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-23 21:00:00+0900 - 2022-04-23 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official E - RLE Editorial by PCTprobability \\(\\mathrm{dp}[i][j] :=(|S|=i,|T|=j\\) となる文字列 \\(S\\) の個数 \\()\\) と定義した動的計画法を考えます。 \\(S_i \\not = S_{i+1}\\) かつ \\(S_{i+1}=S_{i+2}=\\dots =S_{i+k}\\) となる \\(k\\) 文字の部分を追加することを考えると、遷移は以下のようになります。 ・ \\(\\mathrm{dp}[i+k][j+1+k\\) の桁数 \\(]+=dp[i][j] \\times 25\\ (1 \\le k \\le N)\\) ですが、このままでは計算量が \\(\\mathrm{O}(N^3)\\) となってしまいます。 ここで、 \\(1 + k\\) の桁数は \\(\\lceil \\log_{10} (N+1) \\rceil\\) 種類の値しかとらないため、 \\(1+k\\) の桁数が同じ遷移をまとめ、かつ累積和を取りながら動的計画法をすることで高速化できます。 これにより \\(1\\) 箇所の遷移を \\(\\mathrm{O}(\\log N)\\) でできるため、計算量 \\(\\mathrm{O}(N^2\\log N)\\) でこの問題を解くことができます。 実装例(C++) #include <bits/stdc++.h> using namespace std; using ll = long long; ll modPow(ll a, ll n, ll mod) { if(mod==1) return 0;ll ret = 1; ll p = a % mod; while (n) { if (n & 1) ret = ret * p % mod; p = p * p % mod; n >>= 1; } return ret\n\n[Candidate Tags]\nKDP: 桁DP\\nDP: DP\\nBDP: bitDP\\nCOW: 牛ゲー\\nCUM: 累積和\\nEDP: 確率/期待値DP\\nMIT: 半分全列挙\\nTDP: 木DP\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["KDP", "DP", "BDP", "COW", "CUM", "EDP", "MIT", "TDP"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc249_f", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-23 21:00:00+0900 - 2022-04-23 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official F - Ignore Operations Editorial by KoD \\(t_i = 1\\) であるような操作を 代入操作 、 \\(t_i = 2\\) であるような操作を 加算操作 と呼ぶことにします。 代入操作を行うと、それまでの操作が一旦リセットされます。そこで、 最後に 代入操作を行ったのが \\(k\\) 回目であるとします。 \\(k\\) 回目より前の操作は全て無視せず行うとしてよく、 \\(k\\) 回目より後の代入操作（これが合計 \\(n\\) 回あるとします）は全て無視しなければなりません。 \\(n \\gt K\\) であるとき \\(k\\) 回目が最後の代入操作となるようにすることはできないので、以降 \\(n \\leq K\\) を仮定します。 上の考察から、 \\(k\\) 回目より後の加算操作を \\(0\\) 回以上 \\(K - n\\) 回以下無視することで \\(x\\) に足される値を最大化するという問題に帰着されます。 \\(k\\) 回目より後の加算操作を \\(y_i\\) が小さい方から順に見て、 \\(y_i < 0\\) である操作のみ、最大 \\(K - n\\) 回無視するのが最適です。しかし、全ての \\(k\\) に対して毎回 \\(y_i\\) をソートして無視する操作を選んでいては、実行時間制限に間に合いません。 そこで、 \\(k\\) を後ろから順番に試していき、毎回無視する操作を選び直すのではなく、それまでの計算結果を利用できるような方法を考えてみます。無視する加算操作の \\(y_i\\) からならなる多重集合を \\(S\\) 、それ以外の加算操作の \\(y_i\\) からなる多重集合を \\(T\\) とおくと、 \\(|S| \\leq K - n\\) \\(\\displaystyle \\max_{x \\in S} x \\leq \\min_{x \\in T} x\\)\n\n[Candidate Tags]\nOPT: 最適化\\nDP: DP\\nCUM: 累積和\\nDIV: 約数列挙\\nCMB: 組み合わせ\\nEUC: ユークリッドの互除法\\nMIT: 半分全列挙\\nMOS: Mo's algorithm\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["OPT", "DP", "CUM", "DIV", "CMB", "EUC", "MIT", "MOS"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n{"custom_id": "tag_inference_abc249_g", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "o4-mini", "messages": [{"role": "system", "content": "あなたは競技プログラミングのタグ付け専門家です。\n問題と解説を読んで、候補タグから3つ選択し、各タグの確信度(0-1)と根拠を必ず示してください。", "cache_control": {"type": "ephemeral"}}, {"role": "user", "content": "[Problem]\n\n\n[Editorial]\nContest Duration: 2022-04-23 21:00:00+0900 - 2022-04-23 22:40:00+0900 (local time) (100 minutes) Back to Home Top Tasks Clarifications Results All Submissions Standings Virtual Standings Editorial Official G - Xor Cards Editorial by KoD \\(1\\) 枚以上のカードを好きに選ぶ方法は \\(2^N - 1\\) 通りあり、これは \\(N\\) が大きいとき莫大な数になります。しかし、 \\(A_i, B_i\\) の排他的論理和はこの問題の制約下で \\(2^{30}\\) 通りの値しかとらず、これらの組は高々 \\(2^{30} \\times 2^{30} = 2^{60}\\) 通りです。ここで、「実は \\(N\\) 枚のカードを全て考える必要はなく、 \\(60\\) 枚程度のカードのの組合せで全ての選び方が表現できる のではないか」と予想してみましょう。 異なるカード \\(i, j\\) に対し、 \\(A_j\\) を \\(A_i \\oplus A_j\\) で、 \\(B_j\\) を \\(B_i \\oplus B_j\\) で置き換えても答えは変わりません、これは以下の考察からわかります。 置き換える前のカード \\(j\\) を選ぶことは、置き換えた後のカード \\(i, j\\) を両方選ぶことに対応する。 置き換える前のカード \\(i, j\\) を両方選ぶことは、置き換えた後のカード \\(j\\) を選ぶことに対応する。 \\(i \\, (1 \\leq i \\leq N)\\) 行目に \\(A_i\\) の二進表記と \\(B_i\\) の二進表記が並んでいるような行列を考えます。入力例 \\(1\\) に対応する行列は以下のようになります。 \\[\\left(\\begin{array}{cc|cc} 0 & 1 & 0 & 1 \\\\ 1 & 1 & 1 & 0 \\\\ 1 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ \\end{array}\\right)\\] 「行 \\(i, j\\) を入れ替える」「行 \\(j\\) の各成分を行 \\(i\\) との排他的論理和で置き\n\n[Candidate Tags]\nDIV: 約数列挙\\nCMB: 組み合わせ\\nMAT: 行列\\nBPM: 二部マッチング\\nSCH: 区間スケジューリング\\nCAT: カタラン数\\nPIE: 包除原理\\nMOS: Mo's algorithm\n\n上記から3つのタグを選び、各タグの確信度(0-1)と根拠を示してください。"}], "response_format": {"type": "json_schema", "json_schema": {"name": "tag_confidence", "schema": {"type": "object", "properties": {"selected_tags": {"type": "array", "items": {"type": "object", "properties": {"tag_id": {"type": "string", "enum": ["DIV", "CMB", "MAT", "BPM", "SCH", "CAT", "PIE", "MOS"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["tag_id", "confidence", "reasoning"]}, "minItems": 3, "maxItems": 3}}, "required": ["selected_tags"]}}}}}\n